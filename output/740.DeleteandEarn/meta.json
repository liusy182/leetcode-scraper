{
  "id": "740",
  "title": "Delete and Earn",
  "slug": "delete-and-earn",
  "difficulty": "Medium",
  "likes": 655,
  "dislikes": 57,
  "hints": [
    "If you take a number, you might as well take them all.  Keep track of what the value is of the subset of the input with maximum M when you either take or don't take M."
  ],
  "isPaidOnly": false,
  "similarQuestions": "[{\"title\": \"House Robber\", \"titleSlug\": \"house-robber\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
  "solution": {
    "id": "314",
    "canSeeDetail": true,
    "__typename": "ArticleNode",
    "TBKVkiLD": [
      {
        "code": "class Solution {\n    public int deleteAndEarn(int[] nums) {\n        int[] count = new int[10001];\n        for (int x: nums) count[x]++;\n        int avoid = 0, using = 0, prev = -1;\n\n        for (int k = 0; k <= 10000; ++k) if (count[k] > 0) {\n            int m = Math.max(avoid, using);\n            if (k - 1 != prev) {\n                using = k * count[k] + m;\n                avoid = m;\n            } else {\n                using = k * count[k] + avoid;\n                avoid = m;\n            }\n            prev = k;\n        }\n        return Math.max(avoid, using);\n    }\n}",
        "langSlug": "java"
      },
      {
        "code": "class Solution(object):\n    def deleteAndEarn(self, nums):\n        count = collections.Counter(nums)\n        prev = None\n        avoid = using = 0\n        for k in sorted(count):\n            if k - 1 != prev:\n                avoid, using = max(avoid, using), k * count[k] + max(avoid, using)\n            else:\n                avoid, using = max(avoid, using), k * count[k] + avoid\n            prev = k\n        return max(avoid, using)",
        "langSlug": "python"
      }
    ]
  },
  "topicTags": [
    "Dynamic Programming"
  ]
}