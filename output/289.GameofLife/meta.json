{
  "id": "289",
  "title": "Game of Life",
  "slug": "game-of-life",
  "difficulty": "Medium",
  "likes": 1094,
  "dislikes": 201,
  "hints": [],
  "isPaidOnly": false,
  "similarQuestions": "[{\"title\": \"Set Matrix Zeroes\", \"titleSlug\": \"set-matrix-zeroes\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
  "solution": {
    "id": "729",
    "canSeeDetail": true,
    "__typename": "ArticleNode",
    "6cjUENkE": [
      {
        "code": "class Solution {\n    public void gameOfLife(int[][] board) {\n\n        // Neighbors array to find 8 neighboring cells for a given cell\n        int[] neighbors = {0, 1, -1};\n\n        int rows = board.length;\n        int cols = board[0].length;\n\n        // Create a copy of the original board\n        int[][] copyBoard = new int[rows][cols];\n\n        // Create a copy of the original board\n        for (int row = 0; row < rows; row++) {\n            for (int col = 0; col < cols; col++) {\n                copyBoard[row][col] = board[row][col];\n            }\n        }\n\n        // Iterate through board cell by cell.\n        for (int row = 0; row < rows; row++) {\n            for (int col = 0; col < cols; col++) {\n\n                // For each cell count the number of live neighbors.\n                int liveNeighbors = 0;\n\n                for (int i = 0; i < 3; i++) {\n                    for (int j = 0; j < 3; j++) {\n\n                        if (!(neighbors[i] == 0 && neighbors[j] == 0)) {\n                            int r = (row + neighbors[i]);\n                            int c = (col + neighbors[j]);\n\n                            // Check the validity of the neighboring cell.\n                            // and whether it was originally a live cell.\n                            // The evaluation is done against the copy, since that is never updated.\n                            if ((r < rows && r >= 0) && (c < cols && c >= 0) && (copyBoard[r][c] == 1)) {\n                                liveNeighbors += 1;\n                            }\n                        }\n                    }\n                }\n\n                // Rule 1 or Rule 3\n                if ((copyBoard[row][col] == 1) && (liveNeighbors < 2 || liveNeighbors > 3)) {\n                    board[row][col] = 0;\n                }\n                // Rule 4\n                if (copyBoard[row][col] == 0 && liveNeighbors == 3) {\n                    board[row][col] = 1;\n                }\n            }\n        }\n    }\n}",
        "langSlug": "java"
      },
      {
        "code": "class Solution:\n    def gameOfLife(self, board: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n\n        # Neighbors array to find 8 neighboring cells for a given cell\n        neighbors = [(1,0), (1,-1), (0,-1), (-1,-1), (-1,0), (-1,1), (0,1), (1,1)]\n\n        rows = len(board)\n        cols = len(board[0])\n\n        # Create a copy of the original board\n        copy_board = [[board[row][col] for col in range(cols)] for row in range(rows)]\n\n        # Iterate through board cell by cell.\n        for row in range(rows):\n            for col in range(cols):\n\n                # For each cell count the number of live neighbors.\n                live_neighbors = 0\n                for neighbor in neighbors:\n\n                    r = (row + neighbor[0])\n                    c = (col + neighbor[1])\n\n                    # Check the validity of the neighboring cell and if it was originally a live cell.\n                    # The evaluation is done against the copy, since that is never updated.\n                    if (r < rows and r >= 0) and (c < cols and c >= 0) and (copy_board[r][c] == 1):\n                        live_neighbors += 1\n\n                # Rule 1 or Rule 3        \n                if copy_board[row][col] == 1 and (live_neighbors < 2 or live_neighbors > 3):\n                    board[row][col] = 0\n                # Rule 4\n                if copy_board[row][col] == 0 and live_neighbors == 3:\n                    board[row][col] = 1",
        "langSlug": "python"
      }
    ],
    "5937zKqX": [
      {
        "code": "class Solution {\n    public void gameOfLife(int[][] board) {\n\n        // Neighbors array to find 8 neighboring cells for a given cell\n        int[] neighbors = {0, 1, -1};\n\n        int rows = board.length;\n        int cols = board[0].length;\n\n        // Iterate through board cell by cell.\n        for (int row = 0; row < rows; row++) {\n            for (int col = 0; col < cols; col++) {\n\n                // For each cell count the number of live neighbors.\n                int liveNeighbors = 0;\n\n                for (int i = 0; i < 3; i++) {\n                    for (int j = 0; j < 3; j++) {\n\n                        if (!(neighbors[i] == 0 && neighbors[j] == 0)) {\n                            int r = (row + neighbors[i]);\n                            int c = (col + neighbors[j]);\n\n                            // Check the validity of the neighboring cell.\n                            // and whether it was originally a live cell.\n                            if ((r < rows && r >= 0) && (c < cols && c >= 0) && (Math.abs(board[r][c]) == 1)) {\n                                liveNeighbors += 1;\n                            }\n                        }\n                    }\n                }\n\n                // Rule 1 or Rule 3\n                if ((board[row][col] == 1) && (liveNeighbors < 2 || liveNeighbors > 3)) {\n                    // -1 signifies the cell is now dead but originally was live.\n                    board[row][col] = -1;\n                }\n                // Rule 4\n                if (board[row][col] == 0 && liveNeighbors == 3) {\n                    // 2 signifies the cell is now live but was originally dead.\n                    board[row][col] = 2;\n                }\n            }\n        }\n\n        // Get the final representation for the newly updated board.\n        for (int row = 0; row < rows; row++) {\n            for (int col = 0; col < cols; col++) {\n                if (board[row][col] > 0) {\n                    board[row][col] = 1;\n                } else {\n                    board[row][col] = 0;\n                }\n            }\n        }\n    }\n}",
        "langSlug": "java"
      },
      {
        "code": "class Solution:\n    def gameOfLife(self, board: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n        # Neighbors array to find 8 neighboring cells for a given cell\n        neighbors = [(1,0), (1,-1), (0,-1), (-1,-1), (-1,0), (-1,1), (0,1), (1,1)]\n\n        rows = len(board)\n        cols = len(board[0])\n\n        # Iterate through board cell by cell.\n        for row in range(rows):\n            for col in range(cols):\n\n                # For each cell count the number of live neighbors.\n                live_neighbors = 0\n                for neighbor in neighbors:\n\n                    # row and column of the neighboring cell\n                    r = (row + neighbor[0])\n                    c = (col + neighbor[1])\n\n                    # Check the validity of the neighboring cell and if it was originally a live cell.\n                    if (r < rows and r >= 0) and (c < cols and c >= 0) and abs(board[r][c]) == 1:\n                        live_neighbors += 1\n\n                # Rule 1 or Rule 3\n                if board[row][col] == 1 and (live_neighbors < 2 or live_neighbors > 3):\n                    # -1 signifies the cell is now dead but originally was live.\n                    board[row][col] = -1\n                # Rule 4\n                if board[row][col] == 0 and live_neighbors == 3:\n                    # 2 signifies the cell is now live but was originally dead.\n                    board[row][col] = 2\n\n        # Get the final representation for the newly updated board.\n        for row in range(rows):\n            for col in range(cols):\n                if board[row][col] > 0:\n                    board[row][col] = 1\n                else:\n                    board[row][col] = 0",
        "langSlug": "python"
      }
    ],
    "GWyvgQ5K": [
      {
        "code": "def gameOfLifeInfinite(self, live):\n    ctr = collections.Counter((I, J)\n                              for i, j in live\n                              for I in range(i-1, i+2)\n                              for J in range(j-1, j+2)\n                              if I != i or J != j)\n    return {ij\n            for ij in ctr\n            if ctr[ij] == 3 or ctr[ij] == 2 and ij in live}\n\ndef gameOfLife(self, board):\n    live = {(i, j) for i, row in enumerate(board) for j, live in enumerate(row) if live}\n    live = self.gameOfLifeInfinite(live)\n    for i, row in enumerate(board):\n        for j in range(len(row)):\n            row[j] = int((i, j) in live)",
        "langSlug": "python"
      }
    ]
  },
  "topicTags": [
    "Array"
  ]
}