{
  "id": "726",
  "title": "Number of Atoms",
  "slug": "number-of-atoms",
  "difficulty": "Hard",
  "likes": 247,
  "dislikes": 88,
  "hints": [
    "To parse formula[i:], when we see a `'('`, we will parse recursively whatever is inside the brackets (up to the correct closing ending bracket) and add it to our count, multiplying by the following multiplicity if there is one.\r\n\r\nOtherwise, we should see an uppercase character: we will parse the rest of the letters to get the name, and add that (plus the multiplicity if there is one.)"
  ],
  "isPaidOnly": false,
  "similarQuestions": "[{\"title\": \"Decode String\", \"titleSlug\": \"decode-string\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Encode String with Shortest Length\", \"titleSlug\": \"encode-string-with-shortest-length\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Parse Lisp Expression\", \"titleSlug\": \"parse-lisp-expression\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
  "solution": {
    "id": "289",
    "canSeeDetail": true,
    "__typename": "ArticleNode",
    "pdZAZ5dG": [
      {
        "code": "class Solution {\n    int i;\n    public String countOfAtoms(String formula) {\n        StringBuilder ans = new StringBuilder();\n        i = 0;\n        Map<String, Integer> count = parse(formula);\n        for (String name: count.keySet()) {\n            ans.append(name);\n            int multiplicity = count.get(name);\n            if (multiplicity > 1) ans.append(\"\" + multiplicity);\n        }\n        return new String(ans);\n    }\n\n    public Map<String, Integer> parse(String formula) {\n        int N = formula.length();\n        Map<String, Integer> count = new TreeMap();\n        while (i < N && formula.charAt(i) != ')') {\n            if (formula.charAt(i) == '(') {\n                i++;\n                for (Map.Entry<String, Integer> entry: parse(formula).entrySet()) {\n                    count.put(entry.getKey(), count.getOrDefault(entry.getKey(), 0) + entry.getValue());\n                }\n            } else {\n                int iStart = i++;\n                while (i < N && Character.isLowerCase(formula.charAt(i))) i++;\n                String name = formula.substring(iStart, i);\n                iStart = i;\n                while (i < N && Character.isDigit(formula.charAt(i))) i++;\n                int multiplicity = iStart < i ? Integer.parseInt(formula.substring(iStart, i)) : 1;\n                count.put(name, count.getOrDefault(name, 0) + multiplicity);\n            }\n        }\n        int iStart = ++i;\n        while (i < N && Character.isDigit(formula.charAt(i))) i++;\n        if (iStart < i) {\n            int multiplicity = Integer.parseInt(formula.substring(iStart, i));\n            for (String key: count.keySet()) {\n                count.put(key, count.get(key) * multiplicity);\n            }\n        }\n        return count;\n    }\n}",
        "langSlug": "java"
      },
      {
        "code": "class Solution(object):\n    def countOfAtoms(self, formula):\n        def parse():\n            N = len(formula)\n            count = collections.Counter()\n            while (self.i < N and formula[self.i] != ')'):\n                if (formula[self.i] == '('):\n                    self.i += 1\n                    for name, v in parse().items():\n                        count[name] += v\n                else:\n                    i_start = self.i\n                    self.i += 1\n                    while (self.i < N and formula[self.i].islower()):\n                        self.i += 1\n                    name = formula[i_start: self.i]\n                    i_start = self.i\n                    while (self.i < N and formula[self.i].isdigit()):\n                        self.i += 1\n                    count[name] += int(formula[i_start: self.i] or 1)\n            self.i += 1\n            i_start = self.i\n            while (self.i < N and formula[self.i].isdigit()):\n                self.i += 1\n            if (i_start < self.i):\n                multiplicity = int(formula[i_start: self.i])\n                for name in count:\n                    count[name] *= multiplicity\n\n            return count\n\n        self.i = 0\n        ans = []\n        count = parse()\n        for name in sorted(count):\n            ans.append(name)\n            multiplicity = count[name]\n            if multiplicity > 1:\n                ans.append(str(multiplicity))\n        return \"\".join(ans)",
        "langSlug": "python"
      }
    ],
    "KLEWBfKw": [
      {
        "code": "class Solution {\n    public String countOfAtoms(String formula) {\n        int N = formula.length();\n        Stack<Map<String, Integer>> stack = new Stack();\n        stack.push(new TreeMap());\n\n        for (int i = 0; i < N;) {\n            if (formula.charAt(i) == '(') {\n                stack.push(new TreeMap());\n                i++;\n            } else if (formula.charAt(i) == ')') {\n                Map<String, Integer> top = stack.pop();\n                int iStart = ++i, multiplicity = 1;\n                while (i < N && Character.isDigit(formula.charAt(i))) i++;\n                if (i > iStart) multiplicity = Integer.parseInt(formula.substring(iStart, i));\n                for (String c: top.keySet()) {\n                    int v = top.get(c);\n                    stack.peek().put(c, stack.peek().getOrDefault(c, 0) + v * multiplicity);\n                }\n            } else {\n                int iStart = i++;\n                while (i < N && Character.isLowerCase(formula.charAt(i))) i++;\n                String name = formula.substring(iStart, i);\n                iStart = i;\n                while (i < N && Character.isDigit(formula.charAt(i))) i++;\n                int multiplicity = i > iStart ? Integer.parseInt(formula.substring(iStart, i)) : 1;\n                stack.peek().put(name, stack.peek().getOrDefault(name, 0) + multiplicity);\n            }\n        }\n\n        StringBuilder ans = new StringBuilder();\n        for (String name: stack.peek().keySet()) {\n            ans.append(name);\n            int multiplicity = stack.peek().get(name);\n            if (multiplicity > 1) ans.append(\"\" + multiplicity);\n        }\n        return new String(ans);\n    }\n}",
        "langSlug": "java"
      },
      {
        "code": "class Solution(object):\n    def countOfAtoms(self, formula):\n        N = len(formula)\n        stack = [collections.Counter()]\n        i = 0\n        while i < N:\n            if formula[i] == '(':\n                stack.append(collections.Counter())\n                i += 1\n            elif formula[i] == ')':\n                top = stack.pop()\n                i += 1\n                i_start = i\n                while i < N and formula[i].isdigit(): i += 1\n                multiplicity = int(formula[i_start: i] or 1)\n                for name, v in top.items():\n                    stack[-1][name] += v * multiplicity\n            else:\n                i_start = i\n                i += 1\n                while i < N and formula[i].islower(): i += 1\n                name = formula[i_start: i]\n                i_start = i\n                while i < N and formula[i].isdigit(): i += 1\n                multiplicity = int(formula[i_start: i] or 1)\n                stack[-1][name] += multiplicity\n\n        return \"\".join(name + (str(stack[-1][name]) if stack[-1][name] > 1 else '')\n                       for name in sorted(stack[-1]))",
        "langSlug": "python"
      }
    ],
    "rnaR7xpb": [
      {
        "code": "import java.util.regex.*;\n\nclass Solution {\n    public String countOfAtoms(String formula) {\n        Matcher matcher = Pattern.compile(\"([A-Z][a-z]*)(\\\\d*)|(\\\\()|(\\\\))(\\\\d*)\").matcher(formula);\n        Stack<Map<String, Integer>> stack = new Stack();\n        stack.push(new TreeMap());\n\n        while (matcher.find()) {\n            String match = matcher.group();\n            if (match.equals(\"(\")) {\n                stack.push(new TreeMap());\n            } else if (match.startsWith(\")\")) {\n                Map<String, Integer> top = stack.pop();\n                int multiplicity = match.length() > 1 ? Integer.parseInt(match.substring(1, match.length())) : 1;\n                for (String name: top.keySet()) {\n                    stack.peek().put(name, stack.peek().getOrDefault(name, 0) + top.get(name) * multiplicity);\n                }\n            } else {\n                int i = 1;\n                while (i < match.length() && Character.isLowerCase(match.charAt(i))) {\n                    i++;\n                }\n                String name = match.substring(0, i);\n                int multiplicity = i < match.length() ? Integer.parseInt(match.substring(i, match.length())) : 1;\n                stack.peek().put(name, stack.peek().getOrDefault(name, 0) + multiplicity);\n            }\n        }\n\n        StringBuilder ans = new StringBuilder();\n        for (String name: stack.peek().keySet()) {\n            ans.append(name);\n            final int count = stack.peek().get(name);\n            if (count > 1) ans.append(String.valueOf(count));\n        }\n        return ans.toString();\n    }\n}",
        "langSlug": "java"
      },
      {
        "code": "class Solution(object):\n    def countOfAtoms(self, formula):\n        parse = re.findall(r\"([A-Z][a-z]*)(\\d*)|(\\()|(\\))(\\d*)\", formula)\n        stack = [collections.Counter()]\n        for name, m1, left_open, right_open, m2 in parse:\n            if name:\n              stack[-1][name] += int(m1 or 1)\n            if left_open:\n              stack.append(collections.Counter())\n            if right_open:\n                top = stack.pop()\n                for k in top:\n                  stack[-1][k] += top[k] * int(m2 or 1)\n\n        return \"\".join(name + (str(stack[-1][name]) if stack[-1][name] > 1 else '')\n                       for name in sorted(stack[-1]))",
        "langSlug": "python"
      }
    ]
  },
  "topicTags": [
    "Hash Table",
    "Stack",
    "Recursion"
  ]
}