{
  "id": "76",
  "title": "Minimum Window Substring",
  "slug": "minimum-window-substring",
  "difficulty": "Hard",
  "likes": 2723,
  "dislikes": 181,
  "hints": [
    "Use two pointers to create a window of letters in <b>S</b>, which would have all the characters from <b>T</b>.",
    "Since you have to find the minimum window in <b>S</b> which has all the characters from <b>T</b>, you need to expand and contract the window using the two pointers and keep checking the window for all the characters. This approach is also called Sliding Window Approach.\r\n\r\n<br><br>\r\n<pre>\r\nL ------------------------ R , Suppose this is the window that contains all characters of <b>T</b> \r\n                          \r\n&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp L----------------- R , this is the contracted window. We found a smaller window that still contains all the characters in <b>T</b>\r\n\r\nWhen the window is no longer valid, start expanding again using the right pointer. </pre>"
  ],
  "isPaidOnly": false,
  "similarQuestions": "[{\"title\": \"Substring with Concatenation of All Words\", \"titleSlug\": \"substring-with-concatenation-of-all-words\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Minimum Size Subarray Sum\", \"titleSlug\": \"minimum-size-subarray-sum\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Sliding Window Maximum\", \"titleSlug\": \"sliding-window-maximum\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Permutation in String\", \"titleSlug\": \"permutation-in-string\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Smallest Range Covering Elements from K Lists\", \"titleSlug\": \"smallest-range-covering-elements-from-k-lists\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Minimum Window Subsequence\", \"titleSlug\": \"minimum-window-subsequence\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
  "solution": {
    "id": "541",
    "canSeeDetail": true,
    "__typename": "ArticleNode",
    "e5nQuXma": [
      {
        "code": "class Solution {\n  public String minWindow(String s, String t) {\n\n      if (s.length() == 0 || t.length() == 0) {\n          return \"\";\n      }\n\n      // Dictionary which keeps a count of all the unique characters in t.\n      Map<Character, Integer> dictT = new HashMap<Character, Integer>();\n      for (int i = 0; i < t.length(); i++) {\n          int count = dictT.getOrDefault(t.charAt(i), 0);\n          dictT.put(t.charAt(i), count + 1);\n      }\n\n      // Number of unique characters in t, which need to be present in the desired window.\n      int required = dictT.size();\n\n      // Left and Right pointer\n      int l = 0, r = 0;\n\n      // formed is used to keep track of how many unique characters in t\n      // are present in the current window in its desired frequency.\n      // e.g. if t is \"AABC\" then the window must have two A's, one B and one C.\n      // Thus formed would be = 3 when all these conditions are met.\n      int formed = 0;\n\n      // Dictionary which keeps a count of all the unique characters in the current window.\n      Map<Character, Integer> windowCounts = new HashMap<Character, Integer>();\n\n      // ans list of the form (window length, left, right)\n      int[] ans = {-1, 0, 0};\n\n      while (r < s.length()) {\n          // Add one character from the right to the window\n          char c = s.charAt(r);\n          int count = windowCounts.getOrDefault(c, 0);\n          windowCounts.put(c, count + 1);\n\n          // If the frequency of the current character added equals to the\n          // desired count in t then increment the formed count by 1.\n          if (dictT.containsKey(c) && windowCounts.get(c).intValue() == dictT.get(c).intValue()) {\n              formed++;\n          }\n\n          // Try and contract the window till the point where it ceases to be 'desirable'.\n          while (l <= r && formed == required) {\n              c = s.charAt(l);\n              // Save the smallest window until now.\n              if (ans[0] == -1 || r - l + 1 < ans[0]) {\n                  ans[0] = r - l + 1;\n                  ans[1] = l;\n                  ans[2] = r;\n              }\n\n              // The character at the position pointed by the\n              // `Left` pointer is no longer a part of the window.\n              windowCounts.put(c, windowCounts.get(c) - 1);\n              if (dictT.containsKey(c) && windowCounts.get(c).intValue() < dictT.get(c).intValue()) {\n                  formed--;\n              }\n\n              // Move the left pointer ahead, this would help to look for a new window.\n              l++;\n          }\n\n          // Keep expanding the window once we are done contracting.\n          r++;   \n      }\n\n      return ans[0] == -1 ? \"\" : s.substring(ans[1], ans[2] + 1);\n  }\n}",
        "langSlug": "java"
      },
      {
        "code": "def minWindow(self, s, t):\n    \"\"\"\n    :type s: str\n    :type t: str\n    :rtype: str\n    \"\"\"\n\n    if not t or not s:\n        return \"\"\n\n    # Dictionary which keeps a count of all the unique characters in t.\n    dict_t = Counter(t)\n\n    # Number of unique characters in t, which need to be present in the desired window.\n    required = len(dict_t)\n\n    # left and right pointer\n    l, r = 0, 0\n\n    # formed is used to keep track of how many unique characters in t are present in the current window in its desired frequency.\n    # e.g. if t is \"AABC\" then the window must have two A's, one B and one C. Thus formed would be = 3 when all these conditions are met.\n    formed = 0\n\n    # Dictionary which keeps a count of all the unique characters in the current window.\n    window_counts = {}\n\n    # ans tuple of the form (window length, left, right)\n    ans = float(\"inf\"), None, None\n\n    while r < len(s):\n\n        # Add one character from the right to the window\n        character = s[r]\n        window_counts[character] = window_counts.get(character, 0) + 1\n\n        # If the frequency of the current character added equals to the desired count in t then increment the formed count by 1.\n        if character in dict_t and window_counts[character] == dict_t[character]:\n            formed += 1\n\n        # Try and contract the window till the point where it ceases to be 'desirable'.\n        while l <= r and formed == required:\n            character = s[l]\n\n            # Save the smallest window until now.\n            if r - l + 1 < ans[0]:\n                ans = (r - l + 1, l, r)\n\n            # The character at the position pointed by the `left` pointer is no longer a part of the window.\n            window_counts[character] -= 1\n            if character in dict_t and window_counts[character] < dict_t[character]:\n                formed -= 1\n\n            # Move the left pointer ahead, this would help to look for a new window.\n            l += 1    \n\n        # Keep expanding the window once we are done contracting.\n        r += 1    \n    return \"\" if ans[0] == float(\"inf\") else s[ans[1] : ans[2] + 1]",
        "langSlug": "python"
      }
    ],
    "PGDBbStw": [
      {
        "code": "import javafx.util.Pair;\n\nclass Solution {\n    public String minWindow(String s, String t) {\n\n        if (s.length() == 0 || t.length() == 0) {\n            return \"\";\n        }\n\n        Map<Character, Integer> dictT = new HashMap<Character, Integer>();\n\n        for (int i = 0; i < t.length(); i++) {\n            int count = dictT.getOrDefault(t.charAt(i), 0);\n            dictT.put(t.charAt(i), count + 1);\n        }\n\n        int required = dictT.size();\n\n        // Filter all the characters from s into a new list along with their index.\n        // The filtering criteria is that the character should be present in t.\n        List<Pair<Integer, Character>> filteredS = new ArrayList<Pair<Integer, Character>>();\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (dictT.containsKey(c)) {\n                filteredS.add(new Pair<Integer, Character>(i, c));\n            }\n        }\n\n        int l = 0, r = 0, formed = 0;\n        Map<Character, Integer> windowCounts = new HashMap<Character, Integer>();  \n        int[] ans = {-1, 0, 0};\n\n        // Look for the characters only in the filtered list instead of entire s.\n        // This helps to reduce our search.\n        // Hence, we follow the sliding window approach on as small list.\n        while (r < filteredS.size()) {\n            char c = filteredS.get(r).getValue();\n            int count = windowCounts.getOrDefault(c, 0);\n            windowCounts.put(c, count + 1);\n\n            if (dictT.containsKey(c) && windowCounts.get(c).intValue() == dictT.get(c).intValue()) {\n                formed++;\n            }\n\n            // Try and contract the window till the point where it ceases to be 'desirable'.\n            while (l <= r && formed == required) {\n                c = filteredS.get(l).getValue();\n\n                // Save the smallest window until now.\n                int end = filteredS.get(r).getKey();\n                int start = filteredS.get(l).getKey();\n                if (ans[0] == -1 || end - start + 1 < ans[0]) {\n                    ans[0] = end - start + 1;\n                    ans[1] = start;\n                    ans[2] = end;\n                }\n\n                windowCounts.put(c, windowCounts.get(c) - 1);\n                if (dictT.containsKey(c) && windowCounts.get(c).intValue() < dictT.get(c).intValue()) {\n                    formed--;\n                }\n                l++;\n            }\n            r++;   \n        }\n        return ans[0] == -1 ? \"\" : s.substring(ans[1], ans[2] + 1);\n    }\n}",
        "langSlug": "java"
      },
      {
        "code": "def minWindow(self, s, t):\n    \"\"\"\n    :type s: str\n    :type t: str\n    :rtype: str\n    \"\"\"\n    if not t or not s:\n        return \"\"\n\n    dict_t = Counter(t)\n\n    required = len(dict_t)\n\n    # Filter all the characters from s into a new list along with their index.\n    # The filtering criteria is that the character should be present in t.\n    filtered_s = []\n    for i, char in enumerate(s):\n        if char in dict_t:\n            filtered_s.append((i, char))\n\n    l, r = 0, 0\n    formed = 0\n    window_counts = {}\n\n    ans = float(\"inf\"), None, None\n\n    # Look for the characters only in the filtered list instead of entire s. This helps to reduce our search.\n    # Hence, we follow the sliding window approach on as small list.\n    while r < len(filtered_s):\n        character = filtered_s[r][1]\n        window_counts[character] = window_counts.get(character, 0) + 1\n\n        if window_counts[character] == dict_t[character]:\n            formed += 1\n\n        # If the current window has all the characters in desired frequencies i.e. t is present in the window\n        while l <= r and formed == required:\n            character = filtered_s[l][1]\n\n            # Save the smallest window until now.\n            end = filtered_s[r][0]\n            start = filtered_s[l][0]\n            if end - start + 1 < ans[0]:\n                ans = (end - start + 1, start, end)\n\n            window_counts[character] -= 1\n            if window_counts[character] < dict_t[character]:\n                formed -= 1\n            l += 1    \n\n        r += 1    \n    return \"\" if ans[0] == float(\"inf\") else s[ans[1] : ans[2] + 1]",
        "langSlug": "python"
      }
    ]
  },
  "topicTags": [
    "Hash Table",
    "Two Pointers",
    "String",
    "Sliding Window"
  ]
}