{
  "id": "56",
  "title": "Merge Intervals",
  "slug": "merge-intervals",
  "difficulty": "Medium",
  "likes": 2482,
  "dislikes": 192,
  "hints": [],
  "isPaidOnly": false,
  "similarQuestions": "[{\"title\": \"Insert Interval\", \"titleSlug\": \"insert-interval\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Meeting Rooms\", \"titleSlug\": \"meeting-rooms\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Meeting Rooms II\", \"titleSlug\": \"meeting-rooms-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Teemo Attacking\", \"titleSlug\": \"teemo-attacking\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Add Bold Tag in String\", \"titleSlug\": \"add-bold-tag-in-string\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Range Module\", \"titleSlug\": \"range-module\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Employee Free Time\", \"titleSlug\": \"employee-free-time\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Partition Labels\", \"titleSlug\": \"partition-labels\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Interval List Intersections\", \"titleSlug\": \"interval-list-intersections\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
  "solution": {
    "id": "294",
    "canSeeDetail": true,
    "__typename": "ArticleNode",
    "FdD8vWwU": [
      {
        "code": "class Solution {\n    private Map<Interval, List<Interval> > graph;\n    private Map<Integer, List<Interval> > nodesInComp;\n    private Set<Interval> visited;\n\n    // return whether two intervals overlap (inclusive)\n    private boolean overlap(Interval a, Interval b) {\n        return a.start <= b.end && b.start <= a.end;\n    }\n\n    // build a graph where an undirected edge between intervals u and v exists\n    // iff u and v overlap.\n    private void buildGraph(List<Interval> intervals) {\n        graph = new HashMap<>();\n        for (Interval interval : intervals) {\n            graph.put(interval, new LinkedList<>());\n        }\n\n        for (Interval interval1 : intervals) {\n            for (Interval interval2 : intervals) {\n                if (overlap(interval1, interval2)) {\n                    graph.get(interval1).add(interval2);\n                    graph.get(interval2).add(interval1);\n                }\n            }\n        }\n    }\n\n    // merges all of the nodes in this connected component into one interval.\n    private Interval mergeNodes(List<Interval> nodes) {\n        int minStart = nodes.get(0).start;\n        for (Interval node : nodes) {\n            minStart = Math.min(minStart, node.start);\n        }\n\n        int maxEnd = nodes.get(0).end;\n        for (Interval node : nodes) {\n            maxEnd= Math.max(maxEnd, node.end);\n        }\n\n        return new Interval(minStart, maxEnd);\n    }\n\n    // use depth-first search to mark all nodes in the same connected component\n    // with the same integer.\n    private void markComponentDFS(Interval start, int compNumber) {\n        Stack<Interval> stack = new Stack<>();\n        stack.add(start);\n\n        while (!stack.isEmpty()) {\n            Interval node = stack.pop();\n            if (!visited.contains(node)) {\n                visited.add(node);\n\n                if (nodesInComp.get(compNumber) == null) {\n                    nodesInComp.put(compNumber, new LinkedList<>());\n                }\n                nodesInComp.get(compNumber).add(node);\n\n                for (Interval child : graph.get(node)) {\n                    stack.add(child);\n                }\n            }\n        }\n    }\n\n    // gets the connected components of the interval overlap graph.\n    private void buildComponents(List<Interval> intervals) {\n        nodesInComp = new HashMap();\n        visited = new HashSet();\n        int compNumber = 0;\n\n        for (Interval interval : intervals) {\n            if (!visited.contains(interval)) {\n                markComponentDFS(interval, compNumber);\n                compNumber++;\n            }\n        }\n    }\n\n    public List<Interval> merge(List<Interval> intervals) {\n        buildGraph(intervals);\n        buildComponents(intervals);\n\n        // for each component, merge all intervals into one interval.\n        List<Interval> merged = new LinkedList<>();\n        for (int comp = 0; comp < nodesInComp.size(); comp++) {\n            merged.add(mergeNodes(nodesInComp.get(comp)));\n        }\n\n        return merged;\n    }\n}",
        "langSlug": "java"
      },
      {
        "code": "class Solution:\n    def overlap(self, a, b):\n        return a.start <= b.end and b.start <= a.end\n\n    # generate graph where there is an undirected edge between intervals u\n    # and v iff u and v overlap.\n    def build_graph(self, intervals):\n        graph = collections.defaultdict(list)\n\n        for i, interval_i in enumerate(intervals):\n            for j in range(i+1, len(intervals)):\n                if self.overlap(interval_i, intervals[j]):\n                    graph[interval_i].append(intervals[j])\n                    graph[intervals[j]].append(interval_i)\n\n        return graph\n\n    # merges all of the nodes in this connected component into one interval.\n    def merge_nodes(self, nodes):\n        min_start = min(node.start for node in nodes)\n        max_end = max(node.end for node in nodes)\n        return Interval(min_start, max_end)\n\n    # gets the connected components of the interval overlap graph.\n    def get_components(self, graph, intervals):\n        visited = set()\n        comp_number = 0\n        nodes_in_comp = collections.defaultdict(list)\n\n        def mark_component_dfs(start):\n            stack = [start]\n            while stack:\n                node = stack.pop()\n                if node not in visited:\n                    visited.add(node)\n                    nodes_in_comp[comp_number].append(node)\n                    stack.extend(graph[node])\n\n        # mark all nodes in the same connected component with the same integer.\n        for interval in intervals:\n            if interval not in visited:\n                mark_component_dfs(interval)\n                comp_number += 1\n\n        return nodes_in_comp, comp_number\n\n    def merge(self, intervals):\n        graph = self.build_graph(intervals)\n        nodes_in_comp, number_of_comps = self.get_components(graph, intervals)\n\n        # all intervals in each connected component must be merged.\n        return [self.merge_nodes(nodes_in_comp[comp]) for comp in range(number_of_comps)]",
        "langSlug": "python3"
      }
    ],
    "Zum7wj5V": [
      {
        "code": "class Solution {\n    private class IntervalComparator implements Comparator<Interval> {\n        @Override\n        public int compare(Interval a, Interval b) {\n            return a.start < b.start ? -1 : a.start == b.start ? 0 : 1;\n        }\n    }\n\n    public List<Interval> merge(List<Interval> intervals) {\n        Collections.sort(intervals, new IntervalComparator());\n\n        LinkedList<Interval> merged = new LinkedList<Interval>();\n        for (Interval interval : intervals) {\n            // if the list of merged intervals is empty or if the current\n            // interval does not overlap with the previous, simply append it.\n            if (merged.isEmpty() || merged.getLast().end < interval.start) {\n                merged.add(interval);\n            }\n            // otherwise, there is overlap, so we merge the current and previous\n            // intervals.\n            else {\n                merged.getLast().end = Math.max(merged.getLast().end, interval.end);\n            }\n        }\n\n        return merged;\n    }\n}",
        "langSlug": "java"
      },
      {
        "code": "class Solution:\n    def merge(self, intervals):\n        intervals.sort(key=lambda x: x.start)\n\n        merged = []\n        for interval in intervals:\n            # if the list of merged intervals is empty or if the current\n            # interval does not overlap with the previous, simply append it.\n            if not merged or merged[-1].end < interval.start:\n                merged.append(interval)\n            else:\n            # otherwise, there is overlap, so we merge the current and previous\n            # intervals.\n                merged[-1].end = max(merged[-1].end, interval.end)\n\n        return merged",
        "langSlug": "python3"
      }
    ]
  },
  "topicTags": [
    "Array",
    "Sort"
  ]
}