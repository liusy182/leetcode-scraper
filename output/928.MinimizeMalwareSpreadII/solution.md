<div class="article-body">
        
          <div class="block-markdown">
            <div class="toc">
<ul>
<li><a href="#solution">Solution</a><ul>
<li><a href="#approach-1-depth-first-search">Approach 1: Depth First Search</a></li>
<li><a href="#approach-2-union-find">Approach 2: Union-Find</a></li>
</ul>
</li>
</ul>
</div>
<h2 id="solution">Solution</h2>
<hr>
<h4 id="approach-1-depth-first-search">Approach 1: Depth First Search</h4>
<p><strong>Intuition and Algorithm</strong></p>
<p>Let <code>G</code> be the graph with all the nodes from <code>initial</code> removed.</p>
<p>For each node <code>v</code> not in <code>initial</code>, we want to know which nodes <code>u</code> from <code>initial</code> can reach <code>v</code> in the graph <code>G</code> [with <code>u</code> (and its edges) added to <code>G</code>].  Let's say these nodes <code>u</code> "infect" <code>v</code>.</p>
<p>Afterwards, we want to know which nodes <code>v</code> are uniquely infected by only one <code>u</code>.  For each such pair, it contributes 1 to the answer for <code>u</code>.</p>
<p>Please see the inline comments for more details.</p>
<iframe src="https://leetcode.com/playground/zWWFjBM4/shared" frameborder="0" width="100%" height="500" name="zWWFjBM4"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <script type="math/tex; mode=display">O(N^2)</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>graph</code>, as the graph is given in adjacent matrix form.</p>
</li>
<li>
<p>Space Complexity:  <script type="math/tex; mode=display">O(N)</script>.
<br>
<br></p>
</li>
</ul>
<hr>
<h4 id="approach-2-union-find">Approach 2: Union-Find</h4>
<p><strong>Intuition</strong></p>
<p>Let <code>G</code> be the graph with all the nodes in <code>initial</code> removed.  For each component of <code>G</code>, either it neighbors <code>0</code>, <code>1</code>, or <code>&gt;= 2</code> nodes from <code>initial</code>.  The result only changes if there is exactly 1 neighbor from <code>initial</code>, so we need a way to count this.</p>
<p><strong>Algorithm</strong></p>
<p>It is clear that we will need to consider components of the graph.  A "Disjoint Set Union" (DSU) data structure is ideal for this.</p>
<p>We will skip the explanation of how a DSU structure is implemented.  Please refer to <a href="https://leetcode.com/problems/redundant-connection/solution/">https://leetcode.com/problems/redundant-connection/solution/</a> for a tutorial on DSU.</p>
<p>As above, lets consider the components of <code>G</code>: the graph without any nodes from <code>initial</code>.</p>
<p>Then, for every edge <code>uv</code> in the original graph, where <code>u</code> is in initial and <code>v</code> is not, we can count that the component at <code>v</code> of <code>G</code> neighbors 1 more infected node.</p>
<p>Now, for each node <code>u</code> in initial, for each component of <code>G</code> it neighbors, if that component would only be infected by <code>u</code> ("uniquely infected"), then the size of that component contributes to the answer for removing <code>u</code>.</p>
<p>We take the best possible answer.</p>
<iframe src="https://leetcode.com/playground/Bov23LZs/shared" frameborder="0" width="100%" height="500" name="Bov23LZs"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <script type="math/tex; mode=display">O(N^2)</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>graph</code>, as the graph is given in adjacent matrix form.</p>
</li>
<li>
<p>Space Complexity:  <script type="math/tex; mode=display">O(N)</script>.
<br>
<br></p>
</li>
</ul>
<hr>
<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>
          </div>
        
      </div>