{
  "id": "928",
  "title": "Minimize Malware Spread II",
  "slug": "minimize-malware-spread-ii",
  "difficulty": "Hard",
  "likes": 106,
  "dislikes": 29,
  "hints": [],
  "isPaidOnly": false,
  "similarQuestions": "[]",
  "solution": {
    "id": "593",
    "canSeeDetail": true,
    "__typename": "ArticleNode",
    "zWWFjBM4": [
      {
        "code": "class Solution {\n    public int minMalwareSpread(int[][] graph, int[] initial) {\n        int N = graph.length;\n        int[] clean = new int[N];\n        Arrays.fill(clean, 1);\n        for (int x: initial)\n            clean[x] = 0;\n\n        // For each node u in initial, dfs to find\n        // 'seen': all nodes not in initial that it can reach.\n        ArrayList<Integer>[] infectedBy = new ArrayList[N];\n        for (int i = 0; i < N; ++i)\n            infectedBy[i] = new ArrayList();\n\n        for (int u: initial) {\n            Set<Integer> seen = new HashSet();\n            dfs(graph, clean, u, seen);\n            for (int v: seen)\n                infectedBy[v].add(u);\n        }\n\n        // For each node u in initial, for every v not in initial\n        // that is uniquely infected by u, add 1 to the contribution for u.\n        int[] contribution = new int[N];\n        for (int v = 0; v < N; ++v)\n            if (infectedBy[v].size() == 1)\n                contribution[infectedBy[v].get(0)]++;\n\n        // Take the best answer.\n        Arrays.sort(initial);\n        int ans = initial[0], ansSize = -1;\n        for (int u: initial) {\n            int score = contribution[u];\n            if (score > ansSize || score == ansSize && u < ans) {\n                ans = u;\n                ansSize = score;\n            }\n        }\n        return ans;\n    }\n\n    public void dfs(int[][] graph, int[] clean, int u, Set<Integer> seen) {\n        for (int v = 0; v < graph.length; ++v)\n            if (graph[u][v] == 1 && clean[v] == 1 && !seen.contains(v)) {\n                seen.add(v);\n                dfs(graph, clean, v, seen);\n            }\n    }\n}",
        "langSlug": "java"
      },
      {
        "code": "class Solution(object):\n    def minMalwareSpread(self, graph, initial):\n        N = len(graph)\n        clean = set(range(N)) - set(initial)\n        def dfs(u, seen):\n            for v, adj in enumerate(graph[u]):\n                if adj and v in clean and v not in seen:\n                    seen.add(v)\n                    dfs(v, seen)\n\n        # For each node u in initial, dfs to find\n        # 'seen': all nodes not in initial that it can reach.\n        infected_by = {v: [] for v in clean}\n        for u in initial:\n            seen = set()\n            dfs(u, seen)\n\n            # For each node v that was seen, u infects v.\n            for v in seen:\n                infected_by[v].append(u)\n\n        # For each node u in initial, for every v not in initial\n        # that is uniquely infected by u, add 1 to the contribution for u.\n        contribution = collections.Counter()\n        for v, neighbors in infected_by.iteritems():\n            if len(neighbors) == 1:\n                contribution[neighbors[0]] += 1\n\n        # Take the best answer.\n        best = (-1, min(initial))\n        for u, score in contribution.iteritems():\n            if score > best[0] or score == best[0] and u < best[1]:\n                best = score, u\n        return best[1]",
        "langSlug": "python"
      }
    ],
    "Bov23LZs": [
      {
        "code": "class Solution {\n    public int minMalwareSpread(int[][] graph, int[] initial) {\n        int N = graph.length;\n        DSU dsu = new DSU(N);\n\n        // clean[u] == 1 if its a node in the graph not in initial.\n        int[] clean = new int[N];\n        Arrays.fill(clean, 1);\n        for (int x: initial) clean[x] = 0;\n\n        for (int u = 0; u < N; ++u) if (clean[u] == 1)\n            for (int v = 0; v < N; ++v) if (clean[v] == 1)\n                if (graph[u][v] == 1)\n                    dsu.union(u, v);\n\n        // dsu now represents the components of the graph without\n        // any nodes from initial.  Let's call this graph G.\n        int[] count = new int[N];\n        Map<Integer, Set<Integer>> nodeToCompo = new HashMap();\n        for (int u: initial) {\n            Set<Integer> components = new HashSet();\n            for (int v = 0; v < N; ++v) if (clean[v] == 1) {\n                if (graph[u][v] == 1)\n                    components.add(dsu.find(v));\n            }\n\n            nodeToCompo.put(u, components);\n            for (int c: components)\n                count[c]++;\n        }\n\n        // For each node u in initial, nodeToCompo.get(u)\n        // now has every component from G that u neighbors.\n\n        int ans = -1, ansSize = -1;\n        for (int u: nodeToCompo.keySet()) {\n            Set<Integer> components = nodeToCompo.get(u);\n            int score = 0;\n            for (int c: components)\n                if (count[c] == 1) // uniquely infected\n                    score += dsu.size(c);\n\n            if (score > ansSize || score == ansSize && u < ans) {\n                ansSize = score;\n                ans = u;\n            }\n        }\n\n        return ans;\n    }\n}\n\n\nclass DSU {\n    int[] p, sz;\n\n    DSU(int N) {\n        p = new int[N];\n        for (int x = 0; x < N; ++x)\n            p[x] = x;\n\n        sz = new int[N];\n        Arrays.fill(sz, 1);\n    }\n\n    public int find(int x) {\n        if (p[x] != x)\n            p[x] = find(p[x]);\n        return p[x];\n    }\n\n    public void union(int x, int y) {\n        int xr = find(x);\n        int yr = find(y);\n        p[xr] = yr;\n        sz[yr] += sz[xr];\n    }\n\n    public int size(int x) {\n        return sz[find(x)];\n    }\n}",
        "langSlug": "java"
      },
      {
        "code": "class DSU:\n    def __init__(self, N):\n        self.p = range(N)\n        self.sz = [1] * N\n\n    def find(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x]\n\n    def union(self, x, y):\n        xr = self.find(x)\n        yr = self.find(y)\n        self.p[xr] = yr\n        self.sz[yr] += self.sz[xr]\n\n    def size(self, x):\n        return self.sz[self.find(x)]\n\n\nclass Solution(object):\n    def minMalwareSpread(self, graph, initial):\n        N = len(graph)\n        initial_set = set(initial)\n        clean = [x for x in range(N) if x not in initial_set]\n\n        # clean[u] == 1 if its a node in the graph not in initial.\n        dsu = DSU(N)\n        for u in clean:\n            for v in clean:\n                if graph[u][v]:\n                    dsu.union(u, v)\n\n        # dsu now represents the components of the graph without\n        # any nodes from initial.  Let's call this graph G.\n        count = collections.Counter()\n        node_to_compo = {}\n        for u in initial:\n            components = set()\n            for v in clean:\n                if graph[u][v]:\n                    components.add(dsu.find(v))\n            node_to_compo[u] = components\n\n            for c in components:\n                count[c] += 1\n\n        # For each node u in initial, nodeToCompo.get(u)\n        # now has every component from G that u neighbors.\n\n        best = (-1, None) # score, node\n        for u, components in node_to_compo.iteritems():\n            score = 0\n            for c in components:\n                if count[c] == 1: #uniquely infected\n                    score += dsu.size(c)\n            if score > best[0] or score == best[0] and u < best[1]:\n                best = (score, u)\n\n        return best[1]",
        "langSlug": "python"
      }
    ]
  },
  "topicTags": [
    "Depth-first Search",
    "Union Find",
    "Graph"
  ]
}