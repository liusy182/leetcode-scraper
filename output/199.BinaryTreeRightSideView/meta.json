{
  "id": "199",
  "title": "Binary Tree Right Side View",
  "slug": "binary-tree-right-side-view",
  "difficulty": "Medium",
  "likes": 1250,
  "dislikes": 64,
  "hints": [],
  "isPaidOnly": false,
  "similarQuestions": "[{\"title\": \"Populating Next Right Pointers in Each Node\", \"titleSlug\": \"populating-next-right-pointers-in-each-node\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Boundary of Binary Tree\", \"titleSlug\": \"boundary-of-binary-tree\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
  "solution": {
    "id": "274",
    "canSeeDetail": true,
    "__typename": "ArticleNode",
    "U8377M7P": [
      {
        "code": "class Solution {\n    public List<Integer> rightSideView(TreeNode root) {\n        Map<Integer, Integer> rightmostValueAtDepth = new HashMap<Integer, Integer>();\n        int max_depth = -1;\n\n        /* These two stacks are always synchronized, providing an implicit\n         * association values with the same offset on each stack. */\n        Stack<TreeNode> nodeStack = new Stack<TreeNode>();\n        Stack<Integer> depthStack = new Stack<Integer>();\n        nodeStack.push(root);\n        depthStack.push(0);\n\n        while (!nodeStack.isEmpty()) {\n            TreeNode node = nodeStack.pop();\n            int depth = depthStack.pop();\n\n            if (node != null) {\n                max_depth = Math.max(max_depth, depth);\n\n                /* The first node that we encounter at a particular depth contains\n                * the correct value. */\n                if (!rightmostValueAtDepth.containsKey(depth)) {\n                    rightmostValueAtDepth.put(depth, node.val);\n                }\n\n                nodeStack.push(node.left);\n                nodeStack.push(node.right);\n                depthStack.push(depth+1);\n                depthStack.push(depth+1);\n            }\n        }\n\n        /* Construct the solution based on the values that we end up with at the\n         * end. */\n        List<Integer> rightView = new ArrayList<Integer>();\n        for (int depth = 0; depth <= max_depth; depth++) {\n            rightView.add(rightmostValueAtDepth.get(depth));\n        }\n\n        return rightView;\n    }\n}",
        "langSlug": "java"
      },
      {
        "code": "class Solution(object):\n    def rightSideView(self, root):\n        rightmost_value_at_depth = dict() # depth -> node.val\n        max_depth = -1\n\n        stack = [(root, 0)]\n        while stack:\n            node, depth = stack.pop()\n\n            if node is not None:\n                # maintain knowledge of the number of levels in the tree.\n                max_depth = max(max_depth, depth)\n\n                # only insert into dict if depth is not already present.\n                rightmost_value_at_depth.setdefault(depth, node.val)\n\n                stack.append((node.left, depth+1))\n                stack.append((node.right, depth+1))\n\n        return [rightmost_value_at_depth[depth] for depth in range(max_depth+1)]",
        "langSlug": "python"
      }
    ],
    "9Aia2BUi": [
      {
        "code": "class Solution {\n    public List<Integer> rightSideView(TreeNode root) {\n        Map<Integer, Integer> rightmostValueAtDepth = new HashMap<Integer, Integer>();\n        int max_depth = -1;\n\n        /* These two Queues are always synchronized, providing an implicit\n         * association values with the same offset on each Queue. */\n        Queue<TreeNode> nodeQueue = new LinkedList<TreeNode>();\n        Queue<Integer> depthQueue = new LinkedList<Integer>();\n        nodeQueue.add(root);\n        depthQueue.add(0);\n\n        while (!nodeQueue.isEmpty()) {\n            TreeNode node = nodeQueue.remove();\n            int depth = depthQueue.remove();\n\n            if (node != null) {\n                max_depth = Math.max(max_depth, depth);\n\n                /* The last node that we encounter at a particular depth contains\n                * the correct value, so the correct value is never overwritten. */\n                rightmostValueAtDepth.put(depth, node.val);\n\n                nodeQueue.add(node.left);\n                nodeQueue.add(node.right);\n                depthQueue.add(depth+1);\n                depthQueue.add(depth+1);\n            }\n        }\n\n        /* Construct the solution based on the values that we end up with at the\n         * end. */\n        List<Integer> rightView = new ArrayList<Integer>();\n        for (int depth = 0; depth <= max_depth; depth++) {\n            rightView.add(rightmostValueAtDepth.get(depth));\n        }\n\n        return rightView;\n    }\n}",
        "langSlug": "java"
      },
      {
        "code": "from collections import deque\n\nclass Solution(object):\n    def rightSideView(self, root):\n        rightmost_value_at_depth = dict() # depth -> node.val\n        max_depth = -1\n\n        queue = deque([(root, 0)])\n        while queue:\n            node, depth = queue.popleft()\n\n            if node is not None:\n                # maintain knowledge of the number of levels in the tree.\n                max_depth = max(max_depth, depth)\n\n                # overwrite rightmost value at current depth. the correct value\n                # will never be overwritten, as it is always visited last.\n                rightmost_value_at_depth[depth] = node.val\n\n                queue.append((node.left, depth+1))\n                queue.append((node.right, depth+1))\n\n        return [rightmost_value_at_depth[depth] for depth in range(max_depth+1)]",
        "langSlug": "python"
      }
    ]
  },
  "topicTags": [
    "Tree",
    "Depth-first Search",
    "Breadth-first Search"
  ]
}