{
  "id": "210",
  "title": "Course Schedule II",
  "slug": "course-schedule-ii",
  "difficulty": "Medium",
  "likes": 1184,
  "dislikes": 82,
  "hints": [
    "This problem is equivalent to finding the topological order in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.",
    "<a href=\"https://class.coursera.org/algo-003/lecture/52\" target=\"_blank\">Topological Sort via DFS</a> - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort.",
    "Topological sort could also be done via <a href=\"http://en.wikipedia.org/wiki/Topological_sorting#Algorithms\" target=\"_blank\">BFS</a>."
  ],
  "isPaidOnly": false,
  "similarQuestions": "[{\"title\": \"Course Schedule\", \"titleSlug\": \"course-schedule\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Alien Dictionary\", \"titleSlug\": \"alien-dictionary\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Minimum Height Trees\", \"titleSlug\": \"minimum-height-trees\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Sequence Reconstruction\", \"titleSlug\": \"sequence-reconstruction\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Course Schedule III\", \"titleSlug\": \"course-schedule-iii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
  "solution": {
    "id": "645",
    "canSeeDetail": true,
    "__typename": "ArticleNode",
    "cbLU5sGa": [
      {
        "code": "class Solution {\n  static int WHITE = 1;\n  static int GRAY = 2;\n  static int BLACK = 3;\n\n  boolean isPossible;\n  Map<Integer, Integer> color;\n  Map<Integer, List<Integer>> adjList;\n  List<Integer> topologicalOrder;\n\n  private void init(int numCourses) {\n    this.isPossible = true;\n    this.color = new HashMap<Integer, Integer>();\n    this.adjList = new HashMap<Integer, List<Integer>>();\n    this.topologicalOrder = new ArrayList<Integer>();\n\n    // By default all vertces are WHITE\n    for (int i = 0; i < numCourses; i++) {\n      this.color.put(i, WHITE);\n    }\n  }\n\n  private void dfs(int node) {\n\n    // Don't recurse further if we found a cycle already\n    if (!this.isPossible) {\n      return;\n    }\n\n    // Start the recursion\n    this.color.put(node, GRAY);\n\n    // Traverse on neighboring vertices\n    for (Integer neighbor : this.adjList.getOrDefault(node, new ArrayList<Integer>())) {\n      if (this.color.get(neighbor) == WHITE) {\n        this.dfs(neighbor);\n      } else if (this.color.get(neighbor) == GRAY) {\n        // An edge to a GRAY vertex represents a cycle\n        this.isPossible = false;\n      }\n    }\n\n    // Recursion ends. We mark it as black\n    this.color.put(node, BLACK);\n    this.topologicalOrder.add(node);\n  }\n\n  public int[] findOrder(int numCourses, int[][] prerequisites) {\n\n    this.init(numCourses);\n\n    // Create the adjacency list representation of the graph\n    for (int i = 0; i < prerequisites.length; i++) {\n      int dest = prerequisites[i][0];\n      int src = prerequisites[i][1];\n      List<Integer> lst = adjList.getOrDefault(src, new ArrayList<Integer>());\n      lst.add(dest);\n      adjList.put(src, lst);\n    }\n\n    // If the node is unprocessed, then call dfs on it.\n    for (int i = 0; i < numCourses; i++) {\n      if (this.color.get(i) == WHITE) {\n        this.dfs(i);\n      }\n    }\n\n    int[] order;\n    if (this.isPossible) {\n      order = new int[numCourses];\n      for (int i = 0; i < numCourses; i++) {\n        order[i] = this.topologicalOrder.get(numCourses - i - 1);\n      }\n    } else {\n      order = new int[0];\n    }\n\n    return order;\n  }\n}",
        "langSlug": "java"
      },
      {
        "code": "from collections import defaultdict\nclass Solution:\n\n    WHITE = 1\n    GRAY = 2\n    BLACK = 3\n\n    def findOrder(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n\n        # Create the adjacency list representation of the graph\n        adj_list = defaultdict(list)\n\n        # A pair [a, b] in the input represents edge from b --> a\n        for dest, src in prerequisites:\n            adj_list[src].append(dest)\n\n        topological_sorted_order = []\n        is_possible = True\n\n        # By default all vertces are WHITE\n        color = {k: Solution.WHITE for k in range(numCourses)}\n        def dfs(node):\n            nonlocal is_possible\n\n            # Don't recurse further if we found a cycle already\n            if not is_possible:\n                return\n\n            # Start the recursion\n            color[node] = Solution.GRAY\n\n            # Traverse on neighboring vertices\n            if node in adj_list:\n                for neighbor in adj_list[node]:\n                    if color[neighbor] == Solution.WHITE:\n                        dfs(neighbor)\n                    elif color[neighbor] == Solution.GRAY:\n                         # An edge to a GRAY vertex represents a cycle\n                        is_possible = False\n\n            # Recursion ends. We mark it as black\n            color[node] = Solution.BLACK\n            topological_sorted_order.append(node)\n\n        for vertex in range(numCourses):\n            # If the node is unprocessed, then call dfs on it.\n            if color[vertex] == Solution.WHITE:\n                dfs(vertex)\n\n        return topological_sorted_order[::-1] if is_possible else []",
        "langSlug": "python"
      }
    ],
    "vNWFTrPq": [
      {
        "code": "class Solution {\n  public int[] findOrder(int numCourses, int[][] prerequisites) {\n\n    boolean isPossible = true;\n    Map<Integer, List<Integer>> adjList = new HashMap<Integer, List<Integer>>();\n    int[] indegree = new int[numCourses];\n    int[] topologicalOrder = new int[numCourses];\n\n    // Create the adjacency list representation of the graph\n    for (int i = 0; i < prerequisites.length; i++) {\n      int dest = prerequisites[i][0];\n      int src = prerequisites[i][1];\n      List<Integer> lst = adjList.getOrDefault(src, new ArrayList<Integer>());\n      lst.add(dest);\n      adjList.put(src, lst);\n\n      // Record in-degree of each vertex\n      indegree[dest] += 1;\n    }\n\n    // Add all vertices with 0 in-degree to the queue\n    Queue<Integer> q = new LinkedList<Integer>();\n    for (int i = 0; i < numCourses; i++) {\n      if (indegree[i] == 0) {\n        q.add(i);\n      }\n    }\n\n    int i = 0;\n    // Process until the Q becomes empty\n    while (!q.isEmpty()) {\n      int node = q.remove();\n      topologicalOrder[i++] = node;\n\n      // Reduce the in-degree of each neighbor by 1\n      if (adjList.containsKey(node)) {\n        for (Integer neighbor : adjList.get(node)) {\n          indegree[neighbor]--;\n\n          // If in-degree of a neighbor becomes 0, add it to the Q\n          if (indegree[neighbor] == 0) {\n            q.add(neighbor);\n          }\n        }\n      }\n    }\n\n    // Check to see if topological sort is possible or not.\n    if (i == numCourses) {\n      return topologicalOrder;\n    }\n\n    return new int[0];\n  }\n}",
        "langSlug": "java"
      },
      {
        "code": "from collections import defaultdict\nclass Solution:\n\n    def findOrder(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n\n        # Prepare the graph\n        adj_list = defaultdict(list)\n        indegree = {}\n        for dest, src in prerequisites:\n            adj_list[src].append(dest)\n\n            # Record each node's in-degree\n            indegree[dest] = indegree.get(dest, 0) + 1\n\n        # Queue for maintainig list of nodes that have 0 in-degree\n        zero_indegree_queue = [k for k in range(numCourses) if k not in indegree]\n\n        topological_sorted_order = []\n\n        # Until there are nodes in the Q\n        while zero_indegree_queue:\n\n            # Pop one node with 0 in-degree\n            vertex = zero_indegree_queue.pop(0)\n            topological_sorted_order.append(vertex)\n\n            # Reduce in-degree for all the neighbors\n            if vertex in adj_list:\n                for neighbor in adj_list[vertex]:\n                    indegree[neighbor] -= 1\n\n                    # Add neighbor to Q if in-degree becomes 0\n                    if indegree[neighbor] == 0:\n                        zero_indegree_queue.append(neighbor)\n\n        return topological_sorted_order if len(topological_sorted_order) == numCourses else []",
        "langSlug": "python"
      }
    ]
  },
  "topicTags": [
    "Depth-first Search",
    "Breadth-first Search",
    "Graph",
    "Topological Sort"
  ]
}