{
  "id": "850",
  "title": "Rectangle Area II",
  "slug": "rectangle-area-ii",
  "difficulty": "Hard",
  "likes": 208,
  "dislikes": 23,
  "hints": [],
  "isPaidOnly": false,
  "similarQuestions": "[]",
  "solution": {
    "id": "480",
    "canSeeDetail": true,
    "__typename": "ArticleNode",
    "LVWa7ckv": [
      {
        "code": "class Solution {\n    public int rectangleArea(int[][] rectangles) {\n        int N = rectangles.length;\n\n        long ans = 0;\n        for (int subset = 1; subset < (1<<N); ++subset) {\n            int[] rec = new int[]{0, 0, 1_000_000_000, 1_000_000_000};\n            int parity = -1;\n            for (int bit = 0; bit < N; ++bit)\n                if (((subset >> bit) & 1) != 0) {\n                    rec = intersect(rec, rectangles[bit]);\n                    parity *= -1;\n                }\n            ans += parity * area(rec);\n        }\n\n        long MOD = 1_000_000_007;\n        ans %= MOD;\n        if (ans < 0) ans += MOD;\n        return (int) ans;\n    }\n\n    public long area(int[] rec) {\n        long dx = Math.max(0, rec[2] - rec[0]);\n        long dy = Math.max(0, rec[3] - rec[1]);\n        return dx * dy;\n    }\n\n    public int[] intersect(int[] rec1, int[] rec2) {\n        return new int[]{\n            Math.max(rec1[0], rec2[0]),\n            Math.max(rec1[1], rec2[1]),\n            Math.min(rec1[2], rec2[2]),\n            Math.min(rec1[3], rec2[3]),\n        };\n    }\n}",
        "langSlug": "java"
      },
      {
        "code": "class Solution(object):\n    def rectangleArea(self, rectangles):\n        def intersect(rec1, rec2):\n            return [max(rec1[0], rec2[0]),\n                    max(rec1[1], rec2[1]),\n                    min(rec1[2], rec2[2]),\n                    min(rec1[3], rec2[3])]\n\n        def area(rec):\n            dx = max(0, rec[2] - rec[0])\n            dy = max(0, rec[3] - rec[1])\n            return dx * dy\n\n        ans = 0\n        for size in xrange(1, len(rectangles) + 1):\n            for group in itertools.combinations(rectangles, size):\n                ans += (-1) ** (size + 1) * area(reduce(intersect, group))\n\n        return ans % (10**9 + 7)",
        "langSlug": "python"
      }
    ],
    "hp6mu9MY": [
      {
        "code": "class Solution {\n    public int rectangleArea(int[][] rectangles) {\n        int N = rectangles.length;\n        Set<Integer> Xvals = new HashSet();\n        Set<Integer> Yvals = new HashSet();\n\n        for (int[] rec: rectangles) {\n            Xvals.add(rec[0]);\n            Xvals.add(rec[2]);\n            Yvals.add(rec[1]);\n            Yvals.add(rec[3]);\n        }\n\n        Integer[] imapx = Xvals.toArray(new Integer[0]);\n        Arrays.sort(imapx);\n        Integer[] imapy = Yvals.toArray(new Integer[0]);\n        Arrays.sort(imapy);\n\n        Map<Integer, Integer> mapx = new HashMap();\n        Map<Integer, Integer> mapy = new HashMap();\n        for (int i = 0; i < imapx.length; ++i)\n            mapx.put(imapx[i], i);\n        for (int i = 0; i < imapy.length; ++i)\n            mapy.put(imapy[i], i);\n\n        boolean[][] grid = new boolean[imapx.length][imapy.length];\n        for (int[] rec: rectangles)\n            for (int x = mapx.get(rec[0]); x < mapx.get(rec[2]); ++x)\n                for (int y = mapy.get(rec[1]); y < mapy.get(rec[3]); ++y)\n                    grid[x][y] = true;\n\n        long ans = 0;\n        for (int x = 0; x < grid.length; ++x)\n            for (int y = 0; y < grid[0].length; ++y)\n                if (grid[x][y])\n                    ans += (long) (imapx[x+1] - imapx[x]) * (imapy[y+1] - imapy[y]);\n\n        ans %= 1_000_000_007;\n        return (int) ans;\n    }\n}",
        "langSlug": "java"
      },
      {
        "code": "class Solution(object):\n    def rectangleArea(self, rectangles):\n        N = len(rectangles)\n        Xvals, Yvals = set(), set()\n        for x1, y1, x2, y2 in rectangles:\n            Xvals.add(x1); Xvals.add(x2)\n            Yvals.add(y1); Yvals.add(y2)\n\n        imapx = sorted(Xvals)\n        imapy = sorted(Yvals)\n        mapx = {x: i for i, x in enumerate(imapx)}\n        mapy = {y: i for i, y in enumerate(imapy)}\n\n        grid = [[0] * len(imapy) for _ in imapx]\n        for x1, y1, x2, y2 in rectangles:\n            for x in xrange(mapx[x1], mapx[x2]):\n                for y in xrange(mapy[y1], mapy[y2]):\n                    grid[x][y] = 1\n\n        ans = 0\n        for x, row in enumerate(grid):\n            for y, val in enumerate(row):\n                if val:\n                    ans += (imapx[x+1] - imapx[x]) * (imapy[y+1] - imapy[y])\n        return ans % (10**9 + 7)",
        "langSlug": "python"
      }
    ],
    "vyrMx2Y9": [
      {
        "code": "class Solution {\n    public int rectangleArea(int[][] rectangles) {\n        int OPEN = 0, CLOSE = 1;\n        int[][] events = new int[rectangles.length * 2][];\n        int t = 0;\n        for (int[] rec: rectangles) {\n            events[t++] = new int[]{rec[1], OPEN, rec[0], rec[2]};\n            events[t++] = new int[]{rec[3], CLOSE, rec[0], rec[2]};\n        }\n\n        Arrays.sort(events, (a, b) -> Integer.compare(a[0], b[0]));\n\n        List<int[]> active = new ArrayList();\n        int cur_y = events[0][0];\n        long ans = 0;\n        for (int[] event: events) {\n            int y = event[0], typ = event[1], x1 = event[2], x2 = event[3];\n\n            // Calculate query\n            long query = 0;\n            int cur = -1;\n            for (int[] xs: active) {\n                cur = Math.max(cur, xs[0]);\n                query += Math.max(xs[1] - cur, 0);\n                cur = Math.max(cur, xs[1]);\n            }\n\n            ans += query * (y - cur_y);\n\n            if (typ == OPEN) {\n                active.add(new int[]{x1, x2});\n                Collections.sort(active, (a, b) -> Integer.compare(a[0], b[0]));\n            } else {\n                for (int i = 0; i < active.size(); ++i)\n                    if (active.get(i)[0] == x1 && active.get(i)[1] == x2) {\n                        active.remove(i);\n                        break;\n                    }\n            }\n\n            cur_y = y;\n        }\n\n        ans %= 1_000_000_007;\n        return (int) ans;\n    }\n}",
        "langSlug": "java"
      },
      {
        "code": "class Solution(object):\n    def rectangleArea(self, rectangles):\n        # Populate events\n        OPEN, CLOSE = 0, 1\n        events = []\n        for x1, y1, x2, y2 in rectangles:\n            events.append((y1, OPEN, x1, x2))\n            events.append((y2, CLOSE, x1, x2))\n        events.sort()\n\n        def query():\n            ans = 0\n            cur = -1\n            for x1, x2 in active:\n                cur = max(cur, x1)\n                ans += max(0, x2 - cur)\n                cur = max(cur, x2)\n            return ans\n\n        active = []\n        cur_y = events[0][0]\n        ans = 0\n        for y, typ, x1, x2 in events:\n            # For all vertical ground covered, update answer\n            ans += query() * (y - cur_y)\n\n            # Update active intervals\n            if typ is OPEN:\n                active.append((x1, x2))\n                active.sort()\n            else:    \n                active.remove((x1, x2))\n\n            cur_y = y\n\n        return ans % (10**9 + 7)",
        "langSlug": "python"
      }
    ],
    "MmabC4t6": [
      {
        "code": "class Solution {\n    public int rectangleArea(int[][] rectangles) {\n        int OPEN = 1, CLOSE = -1;\n        int[][] events = new int[rectangles.length * 2][];\n        Set<Integer> Xvals = new HashSet();\n        int t = 0;\n        for (int[] rec: rectangles) {\n            events[t++] = new int[]{rec[1], OPEN, rec[0], rec[2]};\n            events[t++] = new int[]{rec[3], CLOSE, rec[0], rec[2]};\n            Xvals.add(rec[0]);\n            Xvals.add(rec[2]);\n        }\n\n        Arrays.sort(events, (a, b) -> Integer.compare(a[0], b[0]));\n\n        Integer[] X = Xvals.toArray(new Integer[0]);\n        Arrays.sort(X);\n        Map<Integer, Integer> Xi = new HashMap();\n        for (int i = 0; i < X.length; ++i)\n            Xi.put(X[i], i);\n\n        Node active = new Node(0, X.length - 1, X);\n        long ans = 0;\n        long cur_x_sum = 0;\n        int cur_y = events[0][0];\n\n        for (int[] event: events) {\n            int y = event[0], typ = event[1], x1 = event[2], x2 = event[3];\n            ans += cur_x_sum * (y - cur_y);\n            cur_x_sum = active.update(Xi.get(x1), Xi.get(x2), typ);\n            cur_y = y;\n\n        }\n\n        ans %= 1_000_000_007;\n        return (int) ans;\n    }\n}\n\nclass Node {\n    int start, end;\n    Integer[] X;\n    Node left, right;\n    int count;\n    long total;\n\n    public Node(int start, int end, Integer[] X) {\n        this.start = start;\n        this.end = end;\n        this.X = X;\n        left = null;\n        right = null;\n        count = 0;\n        total = 0;\n    }\n\n    public int getRangeMid() {\n        return start + (end - start) / 2;\n    }\n\n    public Node getLeft() {\n        if (left == null) left = new Node(start, getRangeMid(), X);\n        return left;\n    }\n\n    public Node getRight() {\n        if (right == null) right = new Node(getRangeMid(), end, X);\n        return right;\n    }\n\n    public long update(int i, int j, int val) {\n        if (i >= j) return 0;\n        if (start == i && end == j) {\n            count += val;\n        } else {\n            getLeft().update(i, Math.min(getRangeMid(), j), val);\n            getRight().update(Math.max(getRangeMid(), i), j, val);\n        }\n\n        if (count > 0) total = X[end] - X[start];\n        else total = getLeft().total + getRight().total;\n\n        return total;\n    }\n}",
        "langSlug": "java"
      },
      {
        "code": "class Node(object):\n    def __init__(self, start, end):\n        self.start, self.end = start, end\n        self.total = self.count = 0\n        self._left = self._right = None\n\n    @property\n    def mid(self):\n        return (self.start + self.end) / 2\n\n    @property\n    def left(self):\n        self._left = self._left or Node(self.start, self.mid)\n        return self._left\n\n    @property\n    def right(self):\n        self._right = self._right or Node(self.mid, self.end)\n        return self._right\n\n    def update(self, i, j, val):\n        if i >= j: return 0\n        if self.start == i and self.end == j:\n            self.count += val\n        else:\n            self.left.update(i, min(self.mid, j), val)\n            self.right.update(max(self.mid, i), j, val)\n\n        if self.count > 0:\n            self.total = X[self.end] - X[self.start]\n        else:\n            self.total = self.left.total + self.right.total\n\n        return self.total\n\nclass Solution(object):\n    def rectangleArea(self, rectangles):\n        OPEN, CLOSE = 1, -1\n        events = []\n        global X\n        X = set()\n        for x1, y1, x2, y2 in rectangles:\n            events.append((y1, OPEN, x1, x2))\n            events.append((y2, CLOSE, x1, x2))\n            X.add(x1)\n            X.add(x2)\n        events.sort()\n\n        X = sorted(X)\n        Xi = {x: i for i, x in enumerate(X)}\n\n        active = Node(0, len(X) - 1)\n        ans = 0\n        cur_x_sum = 0\n        cur_y = events[0][0]\n\n        for y, typ, x1, x2 in events:\n            ans += cur_x_sum * (y - cur_y)\n            cur_x_sum = active.update(Xi[x1], Xi[x2], typ)\n            cur_y = y\n\n        return ans % (10**9 + 7)",
        "langSlug": "python"
      }
    ]
  },
  "topicTags": [
    "Segment Tree",
    "Line Sweep"
  ]
}