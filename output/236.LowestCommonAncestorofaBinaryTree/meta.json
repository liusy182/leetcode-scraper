{
  "id": "236",
  "title": "Lowest Common Ancestor of a Binary Tree",
  "slug": "lowest-common-ancestor-of-a-binary-tree",
  "difficulty": "Medium",
  "likes": 2310,
  "dislikes": 144,
  "hints": [],
  "isPaidOnly": false,
  "similarQuestions": "[{\"title\": \"Lowest Common Ancestor of a Binary Search Tree\", \"titleSlug\": \"lowest-common-ancestor-of-a-binary-search-tree\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
  "solution": {
    "id": "615",
    "canSeeDetail": true,
    "__typename": "ArticleNode",
    "xy87wUjj": [
      {
        "code": "class Solution {\n\n    private TreeNode ans;\n\n    public Solution() {\n        // Variable to store LCA node.\n        this.ans = null;\n    }\n\n    private boolean recurseTree(TreeNode currentNode, TreeNode p, TreeNode q) {\n\n        // If reached the end of a branch, return false.\n        if (currentNode == null) {\n            return false;\n        }\n\n        // Left Recursion. If left recursion returns true, set left = 1 else 0\n        int left = this.recurseTree(currentNode.left, p, q) ? 1 : 0;\n\n        // Right Recursion\n        int right = this.recurseTree(currentNode.right, p, q) ? 1 : 0;\n\n        // If the current node is one of p or q\n        int mid = (currentNode == p || currentNode == q) ? 1 : 0;\n\n\n        // If any two of the flags left, right or mid become True\n        if (mid + left + right >= 2) {\n            this.ans = currentNode;\n        }\n\n        // Return true if any one of the three bool values is True.\n        return (mid + left + right > 0);\n    }\n\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        // Traverse the tree\n        this.recurseTree(root, p, q);\n        return this.ans;\n    }\n}",
        "langSlug": "java"
      },
      {
        "code": "class Solution:\n\n    def __init__(self):\n        # Variable to store LCA node.\n        self.ans = None\n\n    def lowestCommonAncestor(self, root, p, q):\n        \"\"\"\n        :type root: TreeNode\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        def recurse_tree(current_node):\n\n            # If reached the end of a branch, return False.\n            if not current_node:\n                return False\n\n            # Left Recursion\n            left = recurse_tree(current_node.left)\n\n            # Right Recursion\n            right = recurse_tree(current_node.right)\n\n            # If the current node is one of p or q\n            mid = current_node == p or current_node == q\n\n            # If any two of the three flags left, right or mid become True.\n            if mid + left + right >= 2:\n                self.ans = current_node\n\n            # Return True if either of the three bool values is True.\n            return mid or left or right\n\n        # Traverse the tree\n        recurse_tree(root)\n        return self.ans",
        "langSlug": "python"
      }
    ],
    "CVzZroWp": [
      {
        "code": "class Solution {\n\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n\n        // Stack for tree traversal\n        Deque<TreeNode> stack = new ArrayDeque<>();\n\n        // HashMap for parent pointers\n        Map<TreeNode, TreeNode> parent = new HashMap<>();\n\n        parent.put(root, null);\n        stack.push(root);\n\n        // Iterate until we find both the nodes p and q\n        while (!parent.containsKey(p) || !parent.containsKey(q)) {\n\n            TreeNode node = stack.pop();\n\n            // While traversing the tree, keep saving the parent pointers.\n            if (node.left != null) {\n                parent.put(node.left, node);\n                stack.push(node.left);\n            }\n            if (node.right != null) {\n                parent.put(node.right, node);\n                stack.push(node.right);\n            }\n        }\n\n        // Ancestors set() for node p.\n        Set<TreeNode> ancestors = new HashSet<>();\n\n        // Process all ancestors for node p using parent pointers.\n        while (p != null) {\n            ancestors.add(p);\n            p = parent.get(p);\n        }\n\n        // The first ancestor of q which appears in\n        // p's ancestor set() is their lowest common ancestor.\n        while (!ancestors.contains(q))\n            q = parent.get(q);\n        return q;\n    }\n\n}",
        "langSlug": "java"
      },
      {
        "code": "class Solution:\n\n    def lowestCommonAncestor(self, root, p, q):\n        \"\"\"\n        :type root: TreeNode\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n\n        # Stack for tree traversal\n        stack = [root]\n\n        # Dictionary for parent pointers\n        parent = {root: None}\n\n        # Iterate until we find both the nodes p and q\n        while p not in parent or q not in parent:\n\n            node = stack.pop()\n\n            # While traversing the tree, keep saving the parent pointers.\n            if node.left:\n                parent[node.left] = node\n                stack.append(node.left)\n            if node.right:\n                parent[node.right] = node\n                stack.append(node.right)\n\n        # Ancestors set() for node p.\n        ancestors = set()\n\n        # Process all ancestors for node p using parent pointers.\n        while p:\n            ancestors.add(p)\n            p = parent[p]\n\n        # The first ancestor of q which appears in\n        # p's ancestor set() is their lowest common ancestor.\n        while q not in ancestors:\n            q = parent[q]\n        return q",
        "langSlug": "python"
      }
    ],
    "sFHRnjM7": [
      {
        "code": "import javafx.util.*;\n\nclass Solution {\n\n    // Three static flags to keep track of post-order traversal.\n\n    // Both left and right traversal pending for a node.\n    // Indicates the nodes children are yet to be traversed.\n    private static int BOTH_PENDING = 2;\n\n    // Left traversal done.\n    private static int LEFT_DONE = 1;\n\n    // Both left and right traversal done for a node.\n    // Indicates the node can be popped off the stack.\n    private static int BOTH_DONE = 0;\n\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n\n        Stack<Pair<TreeNode, Integer>> stack = new Stack<Pair<TreeNode, Integer>>();\n\n        // Initialize the stack with the root node.\n        stack.push(new Pair<TreeNode, Integer>(root, Solution.BOTH_PENDING));\n\n        // This flag is set when either one of p or q is found.\n        boolean one_node_found = false;\n\n        // This is used to keep track of the LCA.\n        TreeNode LCA = null;\n\n        // Child node\n        TreeNode child_node = null;\n\n        // We do a post order traversal of the binary tree using stack\n        while (!stack.isEmpty()) {\n\n            Pair<TreeNode, Integer> top = stack.peek();\n            TreeNode parent_node = top.getKey();\n            int parent_state = top.getValue();\n\n            // If the parent_state is not equal to BOTH_DONE,\n            // this means the parent_node can't be popped off yet.\n            if (parent_state != Solution.BOTH_DONE) {\n\n                // If both child traversals are pending\n                if (parent_state == Solution.BOTH_PENDING) {\n\n                    // Check if the current parent_node is either p or q.\n                    if (parent_node == p || parent_node == q) {\n\n                        // If one_node_found was set already, this means we have found\n                        // both the nodes.\n                        if (one_node_found) {\n                            return LCA;\n                        } else {\n                            // Otherwise, set one_node_found to True,\n                            // to mark one of p and q is found.\n                            one_node_found = true;\n\n                            // Save the current top element of stack as the LCA.\n                            LCA = stack.peek().getKey();\n                        }\n                    }\n\n                    // If both pending, traverse the left child first\n                    child_node = parent_node.left;\n                } else {\n                    // traverse right child\n                    child_node = parent_node.right;\n                }\n\n                // Update the node state at the top of the stack\n                // Since we have visited one more child.\n                stack.pop();\n                stack.push(new Pair<TreeNode, Integer>(parent_node, parent_state - 1));\n\n                // Add the child node to the stack for traversal.\n                if (child_node != null) {\n                    stack.push(new Pair<TreeNode, Integer>(child_node, Solution.BOTH_PENDING));\n                }\n            } else {\n\n                // If the parent_state of the node is both done,\n                // the top node could be popped off the stack.\n                // Update the LCA node to be the next top node.\n                if (LCA == stack.pop().getKey() && one_node_found) {\n                    LCA = stack.peek().getKey();\n                }\n\n            }\n        }\n\n        return null;\n    }\n}",
        "langSlug": "java"
      },
      {
        "code": "class Solution:\n\n    # Three static flags to keep track of post-order traversal.\n\n    # Both left and right traversal pending for a node.\n    # Indicates the nodes children are yet to be traversed.\n    BOTH_PENDING = 2\n    # Left traversal done.\n    LEFT_DONE = 1\n    # Both left and right traversal done for a node.\n    # Indicates the node can be popped off the stack.\n    BOTH_DONE = 0\n\n    def lowestCommonAncestor(self, root, p, q):\n        \"\"\"\n        :type root: TreeNode\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n\n        # Initialize the stack with the root node.\n        stack = [(root, Solution.BOTH_PENDING)]\n\n        # This flag is set when either one of p or q is found.\n        one_node_found = False\n\n        # This is used to keep track of LCA index.\n        LCA_index = -1\n\n        # We do a post order traversal of the binary tree using stack\n        while stack:\n\n            parent_node, parent_state = stack[-1]\n\n            # If the parent_state is not equal to BOTH_DONE,\n            # this means the parent_node can't be popped of yet.\n            if parent_state != Solution.BOTH_DONE:\n\n                # If both child traversals are pending\n                if parent_state == Solution.BOTH_PENDING:\n\n                    # Check if the current parent_node is either p or q.\n                    if parent_node == p or parent_node == q:\n\n                        # If one_node_found is set already, this means we have found both the nodes.\n                        if one_node_found:\n                            return stack[LCA_index][0]\n                        else:\n                            # Otherwise, set one_node_found to True,\n                            # to mark one of p and q is found.\n                            one_node_found = True\n\n                            # Save the current top index of stack as the LCA_index.\n                            LCA_index = len(stack) - 1\n\n                    # If both pending, traverse the left child first\n                    child_node = parent_node.left\n                else:\n                    # traverse right child\n                    child_node = parent_node.right\n\n                # Update the node state at the top of the stack\n                # Since we have visited one more child.\n                stack.pop()\n                stack.append((parent_node, parent_state - 1))\n\n                # Add the child node to the stack for traversal.\n                if child_node:\n                    stack.append((child_node, Solution.BOTH_PENDING))\n            else:\n\n                # If the parent_state of the node is both done,\n                # the top node could be popped off the stack.\n\n                # i.e. If LCA_index is equal to length of stack. Then we decrease LCA_index by 1.\n                if one_node_found and LCA_index == len(stack) - 1:\n                    LCA_index -= 1\n                stack.pop()\n\n        return None",
        "langSlug": "python"
      }
    ]
  },
  "topicTags": [
    "Tree"
  ],
  "images": {
    "lowest-common-ancestor-of-a-binary-tree_1.png": "https://assets.leetcode.com/uploads/2018/12/14/binarytree.png"
  }
}