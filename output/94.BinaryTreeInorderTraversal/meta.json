{
  "id": "94",
  "title": "Binary Tree Inorder Traversal",
  "slug": "binary-tree-inorder-traversal",
  "difficulty": "Medium",
  "likes": 1915,
  "dislikes": 84,
  "hints": [],
  "isPaidOnly": false,
  "similarQuestions": "[{\"title\": \"Validate Binary Search Tree\", \"titleSlug\": \"validate-binary-search-tree\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Binary Tree Preorder Traversal\", \"titleSlug\": \"binary-tree-preorder-traversal\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Binary Tree Postorder Traversal\", \"titleSlug\": \"binary-tree-postorder-traversal\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Binary Search Tree Iterator\", \"titleSlug\": \"binary-search-tree-iterator\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Kth Smallest Element in a BST\", \"titleSlug\": \"kth-smallest-element-in-a-bst\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Closest Binary Search Tree Value II\", \"titleSlug\": \"closest-binary-search-tree-value-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Inorder Successor in BST\", \"titleSlug\": \"inorder-successor-in-bst\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Convert Binary Search Tree to Sorted Doubly Linked List\", \"titleSlug\": \"convert-binary-search-tree-to-sorted-doubly-linked-list\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum Distance Between BST Nodes\", \"titleSlug\": \"minimum-distance-between-bst-nodes\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
  "solution": {
    "id": "231",
    "canSeeDetail": true,
    "__typename": "ArticleNode",
    "stzQZusR": [
      {
        "code": "class Solution {\n    public List < Integer > inorderTraversal(TreeNode root) {\n        List < Integer > res = new ArrayList < > ();\n        helper(root, res);\n        return res;\n    }\n\n    public void helper(TreeNode root, List < Integer > res) {\n        if (root != null) {\n            if (root.left != null) {\n                helper(root.left, res);\n            }\n            res.add(root.val);\n            if (root.right != null) {\n                helper(root.right, res);\n            }\n        }\n    }\n}",
        "langSlug": "java"
      }
    ],
    "C9344qJ6": [
      {
        "code": "public class Solution {\n    public List < Integer > inorderTraversal(TreeNode root) {\n        List < Integer > res = new ArrayList < > ();\n        Stack < TreeNode > stack = new Stack < > ();\n        TreeNode curr = root;\n        while (curr != null || !stack.isEmpty()) {\n            while (curr != null) {\n                stack.push(curr);\n                curr = curr.left;\n            }\n            curr = stack.pop();\n            res.add(curr.val);\n            curr = curr.right;\n        }\n        return res;\n    }\n}",
        "langSlug": "java"
      }
    ],
    "osLqwuNN": [
      {
        "code": "class Solution {\n    public List < Integer > inorderTraversal(TreeNode root) {\n        List < Integer > res = new ArrayList < > ();\n        TreeNode curr = root;\n        TreeNode pre;\n        while (curr != null) {\n            if (curr.left == null) {\n                res.add(curr.val);\n                curr = curr.right; // move to next right node\n            } else { // has a left subtree\n                pre = curr.left;\n                while (pre.right != null) { // find rightmost\n                    pre = pre.right;\n                }\n                pre.right = curr; // put cur after the pre node\n                TreeNode temp = curr; // store cur node\n                curr = curr.left; // move cur to the top of the new tree\n                temp.left = null; // original cur left be null, avoid infinite loops\n            }\n        }\n        return res;\n    }\n}",
        "langSlug": "java"
      }
    ]
  },
  "topicTags": [
    "Hash Table",
    "Stack",
    "Tree"
  ]
}