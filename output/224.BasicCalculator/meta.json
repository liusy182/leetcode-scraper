{
  "id": "224",
  "title": "Basic Calculator",
  "slug": "basic-calculator",
  "difficulty": "Hard",
  "likes": 901,
  "dislikes": 101,
  "hints": [],
  "isPaidOnly": false,
  "similarQuestions": "[{\"title\": \"Evaluate Reverse Polish Notation\", \"titleSlug\": \"evaluate-reverse-polish-notation\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Basic Calculator II\", \"titleSlug\": \"basic-calculator-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Different Ways to Add Parentheses\", \"titleSlug\": \"different-ways-to-add-parentheses\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Expression Add Operators\", \"titleSlug\": \"expression-add-operators\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Basic Calculator III\", \"titleSlug\": \"basic-calculator-iii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
  "solution": {
    "id": "744",
    "canSeeDetail": true,
    "__typename": "ArticleNode",
    "QJQ2NUUT": [
      {
        "code": "class Solution {\n\n    public int evaluateExpr(Stack<Object> stack) {\n\n        int res = 0;\n\n        if (!stack.empty()) {\n            res = (int) stack.pop();\n        }\n\n        // Evaluate the expression till we get corresponding ')'\n        while (!stack.empty() && !((char) stack.peek() == ')')) {\n\n            char sign = (char) stack.pop();\n\n            if (sign == '+') {\n                res += (int) stack.pop();\n            } else {\n                res -= (int) stack.pop();\n            }\n        }\n        return res;\n    }\n\n    public int calculate(String s) {\n\n        int operand = 0;\n        int n = 0;\n        Stack<Object> stack = new Stack<Object>();\n\n        for (int i = s.length() - 1; i >= 0; i--) {\n\n            char ch = s.charAt(i);\n\n            if (Character.isDigit(ch)) {\n\n                // Forming the operand - in reverse order.\n                operand = (int) Math.pow(10, n) * (int) (ch - '0') + operand;\n                n += 1;\n\n            } else if (ch != ' ') {\n                if (n != 0) {\n\n                    // Save the operand on the stack\n                    // As we encounter some non-digit.\n                    stack.push(operand);\n                    n = 0;\n                    operand = 0;\n\n                }\n                if (ch == '(') {\n\n                    int res = evaluateExpr(stack);\n                    stack.pop();\n\n                    // Append the evaluated result to the stack.\n                    // This result could be of a sub-expression within the parenthesis.\n                    stack.push(res);\n\n                } else {\n                    // For other non-digits just push onto the stack.\n                    stack.push(ch);\n                }\n            }\n        }\n\n        //Push the last operand to stack, if any.\n        if (n != 0) {\n            stack.push(operand);\n        }\n\n        // Evaluate any left overs in the stack.\n        return evaluateExpr(stack);\n    }\n}",
        "langSlug": "java"
      },
      {
        "code": "class Solution:\n\n    def evaluate_expr(self, stack):\n\n        res = stack.pop() if stack else 0\n\n        # Evaluate the expression till we get corresponding ')'\n        while stack and stack[-1] != ')':\n            sign = stack.pop()\n            if sign == '+':\n                res += stack.pop()\n            else:\n                res -= stack.pop()\n        return res       \n\n    def calculate(self, s: str) -> int:\n\n        stack = []\n        n, operand = 0, 0\n\n        for i in range(len(s) - 1, -1, -1):\n            ch = s[i]\n\n            if ch.isdigit():\n\n                # Forming the operand - in reverse order.\n                operand = (10**n * int(ch)) + operand\n                n += 1\n\n            elif ch != \" \":\n                if n:\n                    # Save the operand on the stack\n                    # As we encounter some non-digit.\n                    stack.append(operand)\n                    n, operand = 0, 0\n\n                if ch == '(':         \n                    res = self.evaluate_expr(stack)\n                    stack.pop()        \n\n                    # Append the evaluated result to the stack.\n                    # This result could be of a sub-expression within the parenthesis.\n                    stack.append(res)\n\n                # For other non-digits just push onto the stack.\n                else:\n                    stack.append(ch)\n\n        # Push the last operand to stack, if any.\n        if n:\n            stack.append(operand)\n\n        # Evaluate any left overs in the stack.\n        return self.evaluate_expr(stack)",
        "langSlug": "python"
      }
    ],
    "phpuMfKr": [
      {
        "code": "class Solution {\n    public int calculate(String s) {\n\n        Stack<Integer> stack = new Stack<Integer>();\n        int operand = 0;\n        int result = 0; // For the on-going result\n        int sign = 1;  // 1 means positive, -1 means negative\n\n        for (int i = 0; i < s.length(); i++) {\n\n            char ch = s.charAt(i);\n            if (Character.isDigit(ch)) {\n\n                // Forming operand, since it could be more than one digit\n                operand = 10 * operand + (int) (ch - '0');\n\n            } else if (ch == '+') {\n\n                // Evaluate the expression to the left,\n                // with result, sign, operand\n                result += sign * operand;\n\n                // Save the recently encountered '+' sign\n                sign = 1;\n\n                // Reset operand\n                operand = 0;\n\n            } else if (ch == '-') {\n\n                result += sign * operand;\n                sign = -1;\n                operand = 0;\n\n            } else if (ch == '(') {\n\n                // Push the result and sign on to the stack, for later\n                // We push the result first, then sign\n                stack.push(result);\n                stack.push(sign);\n\n                // Reset operand and result, as if new evaluation begins for the new sub-expression\n                sign = 1;\n                result = 0;\n\n            } else if (ch == ')') {\n\n                // Evaluate the expression to the left\n                // with result, sign and operand\n                result += sign * operand;\n\n                // ')' marks end of expression within a set of parenthesis\n                // Its result is multiplied with sign on top of stack\n                // as stack.pop() is the sign before the parenthesis\n                result *= stack.pop();\n\n                // Then add to the next operand on the top.\n                // as stack.pop() is the result calculated before this parenthesis\n                // (operand on stack) + (sign on stack * (result from parenthesis))\n                result += stack.pop();\n\n                // Reset the operand\n                operand = 0;\n            }\n        }\n        return result + (sign * operand);\n    }\n}",
        "langSlug": "java"
      },
      {
        "code": "class Solution:\n    def calculate(self, s: str) -> int:\n\n        stack = []\n        operand = 0\n        res = 0 # For the on-going result\n        sign = 1 # 1 means positive, -1 means negative  \n\n        for ch in s:\n            if ch.isdigit():\n\n                # Forming operand, since it could be more than one digit\n                operand = (operand * 10) + int(ch)\n\n            elif ch == '+':\n\n                # Evaluate the expression to the left,\n                # with result, sign, operand\n                res += sign * operand\n\n                # Save the recently encountered '+' sign\n                sign = 1\n\n                # Reset operand\n                operand = 0\n\n            elif ch == '-':\n\n                res += sign * operand\n                sign = -1\n                operand = 0\n\n            elif ch == '(':\n\n                # Push the result and sign on to the stack, for later\n                # We push the result first, then sign\n                stack.append(res)\n                stack.append(sign)\n\n                # Reset operand and result, as if new evaluation begins for the new sub-expression\n                sign = 1\n                res = 0\n\n            elif ch == ')':\n\n                # Evaluate the expression to the left\n                # with result, sign and operand\n                res += sign * operand\n\n                # ')' marks end of expression within a set of parenthesis\n                # Its result is multiplied with sign on top of stack\n                # as stack.pop() is the sign before the parenthesis\n                res *= stack.pop() # stack pop 1, sign\n\n                # Then add to the next operand on the top.\n                # as stack.pop() is the result calculated before this parenthesis\n                # (operand on stack) + (sign on stack * (result from parenthesis))\n                res += stack.pop() # stack pop 2, operand\n\n                # Reset the operand\n                operand = 0\n\n        return res + sign * operand",
        "langSlug": "python"
      }
    ]
  },
  "topicTags": [
    "Math",
    "Stack"
  ]
}