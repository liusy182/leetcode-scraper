{
  "id": "770",
  "title": "Basic Calculator IV",
  "slug": "basic-calculator-iv",
  "difficulty": "Hard",
  "likes": 43,
  "dislikes": 381,
  "hints": [
    "One way is with a Polynomial class.  For example,\r\n\r\n* `Poly:add(this, that)` returns the result of `this + that`.\r\n* `Poly:sub(this, that)` returns the result of `this - that`.\r\n* `Poly:mul(this, that)` returns the result of `this * that`.\r\n* `Poly:evaluate(this, evalmap)` returns the polynomial after replacing all free variables with constants as specified by `evalmap`.\r\n* `Poly:toList(this)` returns the polynomial in the correct output format.\r\n\r\n* `Solution::combine(left, right, symbol)` returns the result of applying the binary operator represented by `symbol` to `left` and `right`.\r\n* `Solution::make(expr)` makes a new `Poly` represented by either the constant or free variable specified by `expr`.\r\n* `Solution::parse(expr)` parses an expression into a new `Poly`."
  ],
  "isPaidOnly": false,
  "similarQuestions": "[{\"title\": \"Parse Lisp Expression\", \"titleSlug\": \"parse-lisp-expression\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Basic Calculator III\", \"titleSlug\": \"basic-calculator-iii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
  "solution": {
    "id": "386",
    "canSeeDetail": true,
    "__typename": "ArticleNode",
    "9KquDr4P": [
      {
        "code": "class Solution {\n    public List<String> basicCalculatorIV(String expression, String[] evalVars, int[] evalInts) {\n        Map<String, Integer> evalMap = new HashMap();\n        for (int i = 0; i < evalVars.length; ++i)\n            evalMap.put(evalVars[i], evalInts[i]);\n\n        return parse(expression).evaluate(evalMap).toList();\n    }\n\n    public Poly make(String expr) {\n        Poly ans = new Poly();\n        List<String> list = new ArrayList();\n        if (Character.isDigit(expr.charAt(0))) {\n            ans.update(list, Integer.valueOf(expr));\n        } else {\n            list.add(expr);\n            ans.update(list, 1);\n        }\n        return ans;\n    }\n\n    public Poly combine(Poly left, Poly right, char symbol) {\n        if (symbol == '+') return left.add(right);\n        if (symbol == '-') return left.sub(right);\n        if (symbol == '*') return left.mul(right);\n        throw null;\n    }\n\n    public Poly parse(String expr) {\n        List<Poly> bucket = new ArrayList();\n        List<Character> symbols = new ArrayList();\n        int i = 0;\n        while (i < expr.length()) {\n            if (expr.charAt(i) == '(') {\n                int bal = 0, j = i;\n                for (; j < expr.length(); ++j) {\n                    if (expr.charAt(j) == '(') bal++;\n                    if (expr.charAt(j) == ')') bal--;\n                    if (bal == 0) break;\n                }\n                bucket.add(parse(expr.substring(i+1, j)));\n                i = j;\n            } else if (Character.isLetterOrDigit(expr.charAt(i))) {\n                int j = i;\n                search : {\n                    for (; j < expr.length(); ++j)\n                        if (expr.charAt(j) == ' ') {\n                            bucket.add(make(expr.substring(i, j)));\n                            break search;\n                        }\n                    bucket.add(make(expr.substring(i)));\n                }\n                i = j;\n            } else if (expr.charAt(i) != ' ') {\n                symbols.add(expr.charAt(i));\n            }\n            i++;\n        }\n\n        for (int j = symbols.size() - 1; j >= 0; --j)\n            if (symbols.get(j) == '*')\n                bucket.set(j, combine(bucket.get(j), bucket.remove(j+1), symbols.remove(j)));\n\n        if (bucket.isEmpty()) return new Poly();\n        Poly ans = bucket.get(0);\n        for (int j = 0; j < symbols.size(); ++j)\n            ans = combine(ans, bucket.get(j+1), symbols.get(j));\n\n        return ans;\n    }\n}\n\nclass Poly {\n    HashMap<List<String>, Integer> count;\n    Poly() {count = new HashMap();}\n\n    void update(List<String> key, int val) {\n        this.count.put(key, this.count.getOrDefault(key, 0) + val);\n    }\n\n    Poly add(Poly that) {\n        Poly ans = new Poly();\n        for (List<String> k: this.count.keySet())\n            ans.update(k, this.count.get(k));\n        for (List<String> k: that.count.keySet())\n            ans.update(k, that.count.get(k));\n        return ans;\n    }\n\n    Poly sub(Poly that) {\n        Poly ans = new Poly();\n        for (List<String> k: this.count.keySet())\n            ans.update(k, this.count.get(k));\n        for (List<String> k: that.count.keySet())\n            ans.update(k, -that.count.get(k));\n        return ans;\n    }\n\n    Poly mul(Poly that) {\n        Poly ans = new Poly();\n        for (List<String> k1: this.count.keySet())\n            for (List<String> k2: that.count.keySet()) {\n                List<String> kNew = new ArrayList();\n                for (String x: k1) kNew.add(x);\n                for (String x: k2) kNew.add(x);\n                Collections.sort(kNew);\n                ans.update(kNew, this.count.get(k1) * that.count.get(k2));\n            }\n        return ans;\n    }\n\n    Poly evaluate(Map<String, Integer> evalMap) {\n        Poly ans = new Poly();\n        for (List<String> k: this.count.keySet()) {\n            int c = this.count.get(k);\n            List<String> free = new ArrayList();\n            for (String token: k) {\n                if (evalMap.containsKey(token))\n                    c *= evalMap.get(token);\n                else\n                    free.add(token);\n            }\n            ans.update(free, c);\n        }\n        return ans;\n    }\n\n    int compareList(List<String> A, List<String> B) {\n        int i = 0;\n        for (String x: A) {\n            String y = B.get(i++);\n            if (x.compareTo(y) != 0) return x.compareTo(y);\n        }\n        return 0;\n    }\n    List<String> toList() {\n        List<String> ans = new ArrayList();\n        List<List<String>> keys = new ArrayList(this.count.keySet());\n        Collections.sort(keys, (a, b) ->\n            a.size() != b.size() ? b.size() - a.size() : compareList(a, b));\n\n        for (List<String> key: keys) {\n            int v = this.count.get(key);\n            if (v == 0) continue;\n            StringBuilder word = new StringBuilder();\n            word.append(\"\" + v);\n            for (String token: key) {\n                word.append('*');\n                word.append(token);\n            }\n            ans.add(word.toString());\n        }\n        return ans;\n    }\n}",
        "langSlug": "java"
      },
      {
        "code": "class Poly(collections.Counter):\n    def __add__(self, other):\n        self.update(other)\n        return self\n\n    def __sub__(self, other):\n        self.update({k: -v for k, v in other.items()})\n        return self\n\n    def __mul__(self, other):\n        ans = Poly()\n        for k1, v1 in self.items():\n            for k2, v2 in other.items():\n                ans.update({tuple(sorted(k1 + k2)): v1 * v2})\n        return ans\n\n    def evaluate(self, evalmap):\n        ans = Poly()\n        for k, c in self.items():\n            free = []\n            for token in k:\n                if token in evalmap:\n                    c *= evalmap[token]\n                else:\n                    free.append(token)\n            ans[tuple(free)] += c\n        return ans\n\n    def to_list(self):\n        return [\"*\".join((str(v),) + k)\n                for k, v in sorted(self.items(),\n                    key = lambda (k, v): (-len(k), k, v))\n                if v]\n\nclass Solution(object):\n    def basicCalculatorIV(self, expression, evalvars, evalints):\n        evalmap = dict(zip(evalvars, evalints))\n\n        def combine(left, right, symbol):\n            if symbol == '+': return left + right\n            if symbol == '-': return left - right\n            if symbol == '*': return left * right\n            raise\n\n        def make(expr):\n            ans = Poly()\n            if expr.isdigit():\n                ans.update({(): int(expr)})\n            else:\n                ans[(expr,)] += 1\n            return ans\n\n        def parse(expr):\n            bucket = []\n            symbols = []\n            i = 0\n            while i < len(expr):\n                if expr[i] == '(':\n                    bal = 0\n                    for j in xrange(i, len(expr)):\n                        if expr[j] == '(': bal += 1\n                        if expr[j] == ')': bal -= 1\n                        if bal == 0: break\n                    bucket.append(parse(expr[i+1:j]))\n                    i = j\n                elif expr[i].isalnum():\n                    for j in xrange(i, len(expr)):\n                        if expr[j] == ' ':\n                            bucket.append(make(expr[i:j]))\n                            break\n                    else:\n                        bucket.append(make(expr[i:]))\n                    i = j\n                elif expr[i] in '+-*':\n                    symbols.append(expr[i])\n                i += 1\n\n            for i in xrange(len(symbols) - 1, -1, -1):\n                if symbols[i] == '*':\n                    bucket[i] = combine(bucket[i], bucket.pop(i+1),\n                                        symbols.pop(i))\n\n            if not bucket: return Poly()\n            ans = bucket[0]\n            for i, symbol in enumerate(symbols, 1):\n                ans = combine(ans, bucket[i], symbol)\n\n            return ans\n\n        P = parse(expression).evaluate(evalmap)\n        return P.to_list()",
        "langSlug": "python"
      }
    ]
  },
  "topicTags": [
    "Hash Table",
    "String",
    "Stack"
  ]
}