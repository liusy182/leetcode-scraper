<div class="article-body">
        
          <div class="block-markdown">
            <div class="toc">
<ul>
<li><a href="#solution">Solution</a><ul>
<li><a href="#approach-1-depth-first-search">Approach 1: Depth First Search</a></li>
<li><a href="#approach-2-union-find">Approach 2: Union-Find</a></li>
</ul>
</li>
</ul>
</div>
<h2 id="solution">Solution</h2>
<hr>
<h4 id="approach-1-depth-first-search">Approach 1: Depth First Search</h4>
<p><strong>Intuition</strong></p>
<p>First, let's color (the nodes of) each component of the graph.  We can do this using a depth first search.</p>
<p>Afterwards, notice that if two nodes in <code>initial</code> have the same color (ie., belong to the same component), then removing them from <code>initial</code> won't decrease <code>M(initial)</code>.  This is because the malware will spread to reach every node in this component no matter what.</p>
<p>So, among nodes with a unique color in <code>initial</code>, we will remove the node with the largest component size.  (If there's a tie, we return the smallest index.  Also, if there aren't any nodes with a unique color, we'll just return the smallest index node.)</p>
<p><strong>Algorithm</strong></p>
<p>This algorithm has a few parts:</p>
<ul>
<li>
<p><strong>Coloring each component:</strong>  For each node, if it isn't yet colored, use a depth-first search to traverse its component, coloring that component with a new color.</p>
</li>
<li>
<p><strong>Size of each color:</strong>  Count the number of occurrences of each color.</p>
</li>
<li>
<p><strong>Find unique colors:</strong>  Look at the colors of nodes in <code>initial</code> to see which nodes have unique colors.</p>
</li>
<li>
<p><strong>Choose answer:</strong>  For each node with a unique color, find the size of that color.  The largest size is selected, with ties broken by lowest node number.</p>
<ul>
<li>If there is no node with a unique color, the answer is <code>min(initial)</code>.</li>
</ul>
</li>
</ul>
<iframe src="https://leetcode.com/playground/2UnP5s47/shared" frameborder="0" width="100%" height="500" name="2UnP5s47"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <script type="math/tex; mode=display">O(N^2)</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>graph</code>, as the graph is given in adjacent matrix form.</p>
</li>
<li>
<p>Space Complexity:  <script type="math/tex; mode=display">O(N)</script>.
<br>
<br></p>
</li>
</ul>
<hr>
<h4 id="approach-2-union-find">Approach 2: Union-Find</h4>
<p><strong>Intuition and Algorithm</strong></p>
<p>As in <em>Approach 1</em>, it is clear that we will need to consider components of the graph.  A "Disjoint Set Union" (DSU) data structure is ideal for this.</p>
<p>We will skip the explanation of how a DSU structure is implemented.  Please refer to <a href="https://leetcode.com/problems/redundant-connection/solution/">https://leetcode.com/problems/redundant-connection/solution/</a> for a tutorial on DSU.</p>
<p>To our DSU, we can keep a side count of the size of each component.  Whenever we union two components together, the size of those components are added.</p>
<p>With these details neatly handled by our DSU structure, we can continue in a similar manner to <em>Approach 1</em>: for each node in <code>initial</code> with a unique color, we will consider it as a candidate answer.  If no node in <code>initial</code> have a unique color, then we will take <code>min(initial)</code> as the answer.</p>
<p>Note that for brevity, our <code>DSU</code> implementation does not use union-by-rank.  This makes the asymptotic time complexity larger.</p>
<iframe src="https://leetcode.com/playground/YV58cfEf/shared" frameborder="0" width="100%" height="500" name="YV58cfEf"></iframe>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <script type="math/tex; mode=display">O(N^2)</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>graph</code>, as the graph is given in adjacent matrix form.</p>
</li>
<li>
<p>Space Complexity:  <script type="math/tex; mode=display">O(N)</script>.
<br>
<br></p>
</li>
</ul>
<hr>
<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>
          </div>
        
      </div>