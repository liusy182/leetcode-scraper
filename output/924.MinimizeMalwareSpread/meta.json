{
  "id": "924",
  "title": "Minimize Malware Spread",
  "slug": "minimize-malware-spread",
  "difficulty": "Hard",
  "likes": 186,
  "dislikes": 145,
  "hints": [],
  "isPaidOnly": false,
  "similarQuestions": "[]",
  "solution": {
    "id": "588",
    "canSeeDetail": true,
    "__typename": "ArticleNode",
    "2UnP5s47": [
      {
        "code": "class Solution {\n    public int minMalwareSpread(int[][] graph, int[] initial) {\n        // 1. Color each component.\n        // colors[node] = the color of this node.\n\n        int N = graph.length;\n        int[] colors = new int[N];\n        Arrays.fill(colors, -1);\n        int C = 0;\n\n        for (int node = 0; node < N; ++node)\n            if (colors[node] == -1)\n                dfs(graph, colors, node, C++);\n\n        // 2. Size of each color.\n        int[] size = new int[C];\n        for (int color: colors)\n            size[color]++;\n\n        // 3. Find unique colors.\n        int[] colorCount = new int[C];\n        for (int node: initial)\n            colorCount[colors[node]]++;\n\n        // 4. Answer\n        int ans = Integer.MAX_VALUE;\n        for (int node: initial) {\n            int c = colors[node];\n            if (colorCount[c] == 1) {\n                if (ans == Integer.MAX_VALUE)\n                    ans = node;\n                else if (size[c] > size[colors[ans]])\n                    ans = node;\n                else if (size[c] == size[colors[ans]] && node < ans)\n                    ans = node;\n            }\n        }\n\n        if (ans == Integer.MAX_VALUE)\n            for (int node: initial)\n                ans = Math.min(ans, node);\n\n        return ans;\n    }\n\n    public void dfs(int[][] graph, int[] colors, int node, int color) {\n        colors[node] = color;\n        for (int nei = 0; nei < graph.length; ++nei)\n            if (graph[node][nei] == 1 && colors[nei] == -1)\n                dfs(graph, colors, nei, color);\n    }\n}",
        "langSlug": "java"
      },
      {
        "code": "class Solution(object):\n    def minMalwareSpread(self, graph, initial):\n        # 1. Color each component.\n        # colors[node] = the color of this node.\n\n        N = len(graph)\n        colors = {}\n        c = 0\n\n        def dfs(node, color):\n            colors[node] = color\n            for nei, adj in enumerate(graph[node]):\n                if adj and nei not in colors:\n                    dfs(nei, color)\n\n        for node in xrange(N):\n            if node not in colors:\n                dfs(node, c)\n                c += 1\n\n        # 2. Size of each color.\n        # size[color] = number of occurrences of this color.\n        size = collections.Counter(colors.values())\n\n        # 3. Find unique colors.\n        color_count = collections.Counter()\n        for node in initial:\n            color_count[colors[node]] += 1\n\n        # 4. Answer\n        ans = float('inf')\n        for x in initial:\n            c = colors[x]\n            if color_count[c] == 1:\n                if ans == float('inf'):\n                    ans = x\n                elif size[c] > size[colors[ans]]:\n                    ans = x\n                elif size[c] == size[colors[ans]] and x < ans:\n                    ans = x\n\n        return ans if ans < float('inf') else min(initial)    ",
        "langSlug": "python"
      }
    ],
    "YV58cfEf": [
      {
        "code": "class Solution {\n    public int minMalwareSpread(int[][] graph, int[] initial) {\n        int N = graph.length;\n        DSU dsu = new DSU(N);\n        for (int i = 0; i < N; ++i)\n            for (int j = i+1; j < N; ++j)\n                if (graph[i][j] == 1)\n                    dsu.union(i, j);\n\n        int[] count = new int[N];\n        for (int node: initial)\n            count[dsu.find(node)]++;\n\n        int ans = -1, ansSize = -1;\n        for (int node: initial) {\n            int root = dsu.find(node);\n            if (count[root] == 1) {  // unique color\n                int rootSize = dsu.size(root);\n                if (rootSize > ansSize) {\n                    ansSize = rootSize;\n                    ans = node;\n                } else if (rootSize == ansSize && node < ans) {\n                    ansSize = rootSize;\n                    ans = node;\n                }\n            }\n        }\n\n        if (ans == -1) {\n            ans = Integer.MAX_VALUE;\n            for (int node: initial)\n                ans = Math.min(ans, node);\n        }\n        return ans;\n    }\n}\n\n\nclass DSU {\n    int[] p, sz;\n\n    DSU(int N) {\n        p = new int[N];\n        for (int x = 0; x < N; ++x)\n            p[x] = x;\n\n        sz = new int[N];\n        Arrays.fill(sz, 1);\n    }\n\n    public int find(int x) {\n        if (p[x] != x)\n            p[x] = find(p[x]);\n        return p[x];\n    }\n\n    public void union(int x, int y) {\n        int xr = find(x);\n        int yr = find(y);\n        p[xr] = yr;\n        sz[yr] += sz[xr];\n    }\n\n    public int size(int x) {\n        return sz[find(x)];\n    }\n}",
        "langSlug": "java"
      },
      {
        "code": "class DSU:\n    def __init__(self, N):\n        self.p = range(N)\n        self.sz = [1] * N\n\n    def find(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x]\n\n    def union(self, x, y):\n        xr = self.find(x)\n        yr = self.find(y)\n        self.p[xr] = yr\n        self.sz[yr] += self.sz[xr]\n\n    def size(self, x):\n        return self.sz[self.find(x)]\n\n\nclass Solution(object):\n    def minMalwareSpread(self, graph, initial):\n        dsu = DSU(len(graph))\n\n        for j, row in enumerate(graph):\n            for i in xrange(j):\n                if row[i]:\n                    dsu.union(i, j)\n\n        count = collections.Counter(dsu.find(u) for u in initial)\n        ans = (-1, min(initial))\n        for node in initial:\n            root = dsu.find(node)\n            if count[root] == 1:  # unique color\n                if dsu.size(root) > ans[0]:\n                    ans = dsu.size(root), node\n                elif dsu.size(root) == ans[0] and node < ans[1]:\n                    ans = dsu.size(root), node\n\n        return ans[1]",
        "langSlug": "python"
      }
    ]
  },
  "topicTags": [
    "Depth-first Search",
    "Union Find"
  ]
}