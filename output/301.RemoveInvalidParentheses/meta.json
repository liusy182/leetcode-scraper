{
  "id": "301",
  "title": "Remove Invalid Parentheses",
  "slug": "remove-invalid-parentheses",
  "difficulty": "Hard",
  "likes": 1676,
  "dislikes": 71,
  "hints": [
    "Since we don't know which of the brackets can possibly be removed, we try out all the options!",
    "We can use recursion to try out all possibilities for the given expression. For each of the brackets, we have 2 options:\r\n\r\n<ol>\r\n<li> We keep the bracket and add it to the expression that we are building on the fly during recursion.</li>\r\n<li> OR, we can discard the bracket and move on.\r\n</ol>",
    "The one thing all these valid expressions have in common is that they will all be of the same length i.e. as compared to the original expression, all of these expressions will have the same number of characters removed. \r\n\r\nCan we somehow find the number of misplaced parentheses and use it in our solution?",
    "The one thing all these valid expressions have in common is that they will all be of the same length i.e. as compared to the original expression, all of these expressions will have the same number of characters removed. \r\n\r\nCan we somehow find the number of misplaced parentheses and use it in our solution?",
    "For every left parenthesis, we should have a corresponding right parenthesis. We can make use of two counters which keep track of misplaced left and right parenthesis and in one iteration we can find out these two values. \r\n\r\n<pre>\r\n0 1 2 3 4 5 6 7\r\n( ) ) ) ( ( ( )  \r\ni = 0, left = 1, right = 0\r\ni = 1, left = 0, right = 0\r\ni = 2, left = 0, right = 1\r\ni = 3, left = 0, right = 2\r\ni = 4, left = 1, right = 2\r\ni = 5, left = 2, right = 2\r\ni = 6, left = 3, right = 2\r\ni = 7, left = 2, right = 2\r\n</pre>\r\n\r\nWe have 2 misplaced left and 2 misplaced right parentheses.",
    "We found out that the exact number of left and right parenthesis that has to be removed to get a valid expression. So, e.g. in a 1000 parentheses string, if there are 2 misplaced left and 2 misplaced right parentheses, after we are done discarding 2 left and 2 right parentheses, we will have only one option per remaining character in the expression i.e. to consider them. We can't discard them."
  ],
  "isPaidOnly": false,
  "similarQuestions": "[{\"title\": \"Valid Parentheses\", \"titleSlug\": \"valid-parentheses\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
  "solution": {
    "id": "577",
    "canSeeDetail": true,
    "__typename": "ArticleNode",
    "CqP9Vt73": [
      {
        "code": "class Solution {\n\n  private Set<String> validExpressions = new HashSet<String>();\n  private int minimumRemoved;\n\n  private void reset() {\n    this.validExpressions.clear();\n    this.minimumRemoved = Integer.MAX_VALUE;\n  }\n\n  private void recurse(\n      String s,\n      int index,\n      int leftCount,\n      int rightCount,\n      StringBuilder expression,\n      int removedCount) {\n\n    // If we have reached the end of string.\n    if (index == s.length()) {\n\n      // If the current expression is valid.\n      if (leftCount == rightCount) {\n\n        // If the current count of removed parentheses is <= the current minimum count\n        if (removedCount <= this.minimumRemoved) {\n\n          // Convert StringBuilder to a String. This is an expensive operation.\n          // So we only perform this when needed.\n          String possibleAnswer = expression.toString();\n\n          // If the current count beats the overall minimum we have till now\n          if (removedCount < this.minimumRemoved) {\n            this.validExpressions.clear();\n            this.minimumRemoved = removedCount;\n          }\n          this.validExpressions.add(possibleAnswer);\n        }\n      }\n    } else {\n\n      char currentCharacter = s.charAt(index);\n      int length = expression.length();\n\n      // If the current character is neither an opening bracket nor a closing one,\n      // simply recurse further by adding it to the expression StringBuilder\n      if (currentCharacter != '(' && currentCharacter != ')') {\n        expression.append(currentCharacter);\n        this.recurse(s, index + 1, leftCount, rightCount, expression, removedCount);\n        expression.deleteCharAt(length);\n      } else {\n\n        // Recursion where we delete the current character and move forward\n        this.recurse(s, index + 1, leftCount, rightCount, expression, removedCount + 1);\n        expression.append(currentCharacter);\n\n        // If it's an opening parenthesis, consider it and recurse\n        if (currentCharacter == '(') {\n          this.recurse(s, index + 1, leftCount + 1, rightCount, expression, removedCount);\n        } else if (rightCount < leftCount) {\n          // For a closing parenthesis, only recurse if right < left\n          this.recurse(s, index + 1, leftCount, rightCount + 1, expression, removedCount);\n        }\n\n        // Undoing the append operation for other recursions.\n        expression.deleteCharAt(length);\n      }\n    }\n  }\n\n  public List<String> removeInvalidParentheses(String s) {\n\n    this.reset();\n    this.recurse(s, 0, 0, 0, new StringBuilder(), 0);\n    return new ArrayList(this.validExpressions);\n  }\n}",
        "langSlug": "java"
      },
      {
        "code": "class Solution(object):\n\n    def __init__(self):\n        self.valid_expressions = None\n        self.min_removed = None\n\n    def reset(self):\n        self.valid_expressions = set()\n        self.min_removed = float(\"inf\")\n\n    \"\"\"\n        string: The original string we are recursing on.\n        index: current index in the original string.\n        left: number of left parentheses till now.\n        right: number of right parentheses till now.\n        ans: the resulting expression in this particular recursion.\n        ignored: number of parentheses ignored in this particular recursion.\n    \"\"\"\n    def remaining(self, string, index, left_count, right_count, expr, rem_count):\n        # If we have reached the end of string.\n        if index == len(string):\n\n            # If the current expression is valid. The only scenario where it can be\n            # invalid here is if left > right. The other way around we handled early on in the recursion.\n            if left_count == right_count:\n\n                if rem_count <= self.min_removed:\n                    # This is the resulting expression.\n                    # Strings are immutable in Python so we move around a list in the recursion\n                    # and eventually join to get the final string.\n                    possible_ans = \"\".join(expr)\n\n                    # If the current count of brackets removed < current minimum, ignore\n                    # previous answers and update the current minimum count.\n                    if rem_count < self.min_removed:\n                        self.valid_expressions = set()\n                        self.min_removed = rem_count\n\n                    self.valid_expressions.add(possible_ans)    \n        else:        \n\n            current_char = string[index]\n\n            # If the current character is not a parenthesis, just recurse one step ahead.\n            if current_char != '(' and  current_char != ')':\n                expr.append(current_char)\n                self.remaining(string, index + 1, left_count, right_count, expr, rem_count)\n                expr.pop()\n            else:\n                # Else, one recursion is with ignoring the current character.\n                # So, we increment the ignored counter and leave the left and right untouched.\n                self.remaining(string, index + 1, left_count, right_count, expr, rem_count + 1)\n\n                expr.append(current_char)\n\n                # If the current parenthesis is an opening bracket, we consider it\n                # and increment left and  move forward\n                if string[index] == '(':\n                    self.remaining(string, index + 1, left_count + 1, right_count, expr, rem_count)\n                elif right_count < left_count:\n                    # If the current parenthesis is a closing bracket, we consider it only if we\n                    # have more number of opening brackets and increment right and move forward.\n                    self.remaining(string, index + 1, left_count, right_count + 1, expr, rem_count)\n\n                expr.pop()\n\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n\n        # Reset the class level variables that we use for every test case.\n        self.reset()\n\n        # Recursive call\n        self.remaining(s, 0, 0, 0, [], 0)\n        return list(self.valid_expressions)",
        "langSlug": "python"
      }
    ],
    "YQCnqBTg": [
      {
        "code": "class Solution {\n\n  private Set<String> validExpressions = new HashSet<String>();\n\n  private void recurse(\n      String s,\n      int index,\n      int leftCount,\n      int rightCount,\n      int leftRem,\n      int rightRem,\n      StringBuilder expression) {\n\n    // If we reached the end of the string, just check if the resulting expression is\n    // valid or not and also if we have removed the total number of left and right\n    // parentheses that we should have removed.\n    if (index == s.length()) {\n      if (leftRem == 0 && rightRem == 0) {\n        this.validExpressions.add(expression.toString());\n      }\n\n    } else {\n      char character = s.charAt(index);\n      int length = expression.length();\n\n      // The discard case. Note that here we have our pruning condition.\n      // We don't recurse if the remaining count for that parenthesis is == 0.\n      if ((character == '(' && leftRem > 0) || (character == ')' && rightRem > 0)) {\n        this.recurse(\n            s,\n            index + 1,\n            leftCount,\n            rightCount,\n            leftRem - (character == '(' ? 1 : 0),\n            rightRem - (character == ')' ? 1 : 0),\n            expression);\n      }\n\n      expression.append(character);\n\n      // Simply recurse one step further if the current character is not a parenthesis.\n      if (character != '(' && character != ')') {\n\n        this.recurse(s, index + 1, leftCount, rightCount, leftRem, rightRem, expression);\n\n      } else if (character == '(') {\n\n        // Consider an opening bracket.\n        this.recurse(s, index + 1, leftCount + 1, rightCount, leftRem, rightRem, expression);\n\n      } else if (rightCount < leftCount) {\n\n        // Consider a closing bracket.\n        this.recurse(s, index + 1, leftCount, rightCount + 1, leftRem, rightRem, expression);\n      }\n\n      // Delete for backtracking.\n      expression.deleteCharAt(length);\n    }\n  }\n\n  public List<String> removeInvalidParentheses(String s) {\n\n    int left = 0, right = 0;\n\n    // First, we find out the number of misplaced left and right parentheses.\n    for (int i = 0; i < s.length(); i++) {\n\n      // Simply record the left one.\n      if (s.charAt(i) == '(') {\n        left++;\n      } else if (s.charAt(i) == ')') {\n        // If we don't have a matching left, then this is a misplaced right, record it.\n        right = left == 0 ? right + 1 : right;\n\n        // Decrement count of left parentheses because we have found a right\n        // which CAN be a matching one for a left.\n        left = left > 0 ? left - 1 : left;\n      }\n    }\n\n    this.recurse(s, 0, 0, 0, left, right, new StringBuilder());\n    return new ArrayList<String>(this.validExpressions);\n  }\n}",
        "langSlug": "java"
      },
      {
        "code": "class Solution:\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n\n        left = 0\n        right = 0\n\n        # First, we find out the number of misplaced left and right parentheses.\n        for char in s:\n\n            # Simply record the left one.\n            if char == '(':\n                left += 1\n            elif char == ')':\n                # If we don't have a matching left, then this is a misplaced right, record it.\n                right = right + 1 if left == 0 else right\n\n                # Decrement count of left parentheses because we have found a right\n                # which CAN be a matching one for a left.\n                left = left - 1 if left > 0 else left\n\n        result = {}\n        def recurse(s, index, left_count, right_count, left_rem, right_rem, expr):\n            # If we reached the end of the string, just check if the resulting expression is\n            # valid or not and also if we have removed the total number of left and right\n            # parentheses that we should have removed.\n            if index == len(s):\n                if left_rem == 0 and right_rem == 0:\n                    ans = \"\".join(expr)\n                    result[ans] = 1\n            else:\n\n                # The discard case. Note that here we have our pruning condition.\n                # We don't recurse if the remaining count for that parenthesis is == 0.\n                if (s[index] == '(' and left_rem > 0) or (s[index] == ')' and right_rem > 0):\n                    recurse(s, index + 1,\n                            left_count,\n                            right_count,\n                            left_rem - (s[index] == '('),\n                            right_rem - (s[index] == ')'), expr)\n\n                expr.append(s[index])    \n\n                # Simply recurse one step further if the current character is not a parenthesis.\n                if s[index] != '(' and s[index] != ')':\n                    recurse(s, index + 1,\n                            left_count,\n                            right_count,\n                            left_rem,\n                            right_rem, expr)\n                elif s[index] == '(':\n                    # Consider an opening bracket.\n                    recurse(s, index + 1,\n                            left_count + 1,\n                            right_count,\n                            left_rem,\n                            right_rem, expr)\n                elif s[index] == ')' and left_count > right_count:\n                    # Consider a closing bracket.\n                    recurse(s, index + 1,\n                            left_count,\n                            right_count + 1,\n                            left_rem,\n                            right_rem, expr)\n\n                # Pop for backtracking.\n                expr.pop()                 \n\n        # Now, the left and right variables tell us the number of misplaced left and\n        # right parentheses and that greatly helps pruning the recursion.\n        recurse(s, 0, 0, 0, left, right, [])     \n        return list(result.keys())",
        "langSlug": "python"
      }
    ]
  },
  "topicTags": [
    "Depth-first Search",
    "Breadth-first Search"
  ]
}