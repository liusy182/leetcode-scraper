{
  "id": "855",
  "title": "Exam Room",
  "slug": "exam-room",
  "difficulty": "Medium",
  "likes": 364,
  "dislikes": 167,
  "hints": [],
  "isPaidOnly": false,
  "similarQuestions": "[{\"title\": \"Maximize Distance to Closest Person\", \"titleSlug\": \"maximize-distance-to-closest-person\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
  "solution": {
    "id": "489",
    "canSeeDetail": true,
    "__typename": "ArticleNode",
    "9bZc2mLh": [
      {
        "code": "class ExamRoom {\n    int N;\n    TreeSet<Integer> students;\n\n    public ExamRoom(int N) {\n        this.N = N;\n        students = new TreeSet();\n    }\n\n    public int seat() {\n        //Let's determine student, the position of the next\n        //student to sit down.\n        int student = 0;\n        if (students.size() > 0) {\n            //Tenatively, dist is the distance to the closest student,\n            //which is achieved by sitting in the position 'student'.\n            //We start by considering the left-most seat.\n            int dist = students.first();\n            Integer prev = null;\n            for (Integer s: students) {\n                if (prev != null) {\n                    //For each pair of adjacent students in positions (prev, s),\n                    //d is the distance to the closest student;\n                    //achieved at position prev + d.\n                    int d = (s - prev) / 2;\n                    if (d > dist) {\n                        dist = d;\n                        student = prev + d;\n                    }\n                }\n                prev = s;\n            }\n\n            //Considering the right-most seat.\n            if (N - 1 - students.last() > dist)\n                student = N - 1;\n        }\n\n        //Add the student to our sorted TreeSet of positions.\n        students.add(student);\n        return student;\n    }\n\n    public void leave(int p) {\n        students.remove(p);\n    }\n}",
        "langSlug": "java"
      },
      {
        "code": "class ExamRoom(object):\n    def __init__(self, N):\n        self.N = N\n        self.students = []\n\n    def seat(self):\n        # Let's determine student, the position of the next\n        # student to sit down.\n        if not self.students:\n            student = 0\n        else:\n            # Tenatively, dist is the distance to the closest student,\n            # which is achieved by sitting in the position 'student'.\n            # We start by considering the left-most seat.\n            dist, student = self.students[0], 0\n            for i, s in enumerate(self.students):\n                if i:\n                    prev = self.students[i-1]\n                    # For each pair of adjacent students in positions (prev, s),\n                    # d is the distance to the closest student;\n                    # achieved at position prev + d.\n                    d = (s - prev) / 2\n                    if d > dist:\n                        dist, student = d, prev + d\n\n            # Considering the right-most seat.\n            d = self.N - 1 - self.students[-1]\n            if d > dist:\n                student = self.N - 1\n\n        # Add the student to our sorted list of positions.\n        bisect.insort(self.students, student)\n        return student\n\n    def leave(self, p):\n        self.students.remove(p)",
        "langSlug": "python"
      }
    ]
  },
  "topicTags": [
    "Ordered Map"
  ]
}