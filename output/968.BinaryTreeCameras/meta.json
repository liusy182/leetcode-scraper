{
  "id": "968",
  "title": "Binary Tree Cameras",
  "slug": "binary-tree-cameras",
  "difficulty": "Hard",
  "likes": 337,
  "dislikes": 11,
  "hints": [],
  "isPaidOnly": false,
  "similarQuestions": "[{\"title\": \"Distribute Coins in Binary Tree\", \"titleSlug\": \"distribute-coins-in-binary-tree\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
  "solution": {
    "id": "651",
    "canSeeDetail": true,
    "__typename": "ArticleNode",
    "4oJtky7i": [
      {
        "code": "class Solution {\n    public int minCameraCover(TreeNode root) {\n        int[] ans = solve(root);\n        return Math.min(ans[1], ans[2]);\n    }\n\n    // 0: Strict ST; All nodes below this are covered, but not this one\n    // 1: Normal ST; All nodes below and incl this are covered - no camera\n    // 2: Placed camera; All nodes below this are covered, plus camera here\n    public int[] solve(TreeNode node) {\n        if (node == null)\n            return new int[]{0, 0, 99999};\n\n        int[] L = solve(node.left);\n        int[] R = solve(node.right);\n        int mL12 = Math.min(L[1], L[2]);\n        int mR12 = Math.min(R[1], R[2]);\n\n        int d0 = L[1] + R[1];\n        int d1 = Math.min(L[2] + mR12, R[2] + mL12);\n        int d2 = 1 + Math.min(L[0], mL12) + Math.min(R[0], mR12);\n        return new int[]{d0, d1, d2};\n    }\n}\n",
        "langSlug": "java"
      },
      {
        "code": "class Solution(object):\n    def minCameraCover(self, root):\n        def solve(node):\n            # 0: Strict ST; All nodes below this are covered, but not this one\n            # 1: Normal ST; All nodes below and incl this are covered - no camera\n            # 2: Placed camera; All nodes below this are covered, plus camera here\n\n            if not node: return 0, 0, float('inf')\n            L = solve(node.left)\n            R = solve(node.right)\n\n            dp0 = L[1] + R[1]\n            dp1 = min(L[2] + min(R[1:]), R[2] + min(L[1:]))\n            dp2 = 1 + min(L) + min(R)\n\n            return dp0, dp1, dp2\n\n        return min(solve(root)[1:])",
        "langSlug": "python"
      }
    ],
    "Zhw2ojEo": [
      {
        "code": "class Solution {\n    int ans;\n    Set<TreeNode> covered;\n    public int minCameraCover(TreeNode root) {\n        ans = 0;\n        covered = new HashSet();\n        covered.add(null);\n\n        dfs(root, null);\n        return ans;\n    }\n\n    public void dfs(TreeNode node, TreeNode par) {\n        if (node != null) {\n            dfs(node.left, node);\n            dfs(node.right, node);\n\n            if (par == null && !covered.contains(node) ||\n                    !covered.contains(node.left) ||\n                    !covered.contains(node.right)) {\n                ans++;\n                covered.add(node);\n                covered.add(par);\n                covered.add(node.left);\n                covered.add(node.right);\n            }\n        }\n    }\n}",
        "langSlug": "java"
      },
      {
        "code": "class Solution(object):\n    def minCameraCover(self, root):\n        self.ans = 0\n        covered = {None}\n\n        def dfs(node, par = None):\n            if node:\n                dfs(node.left, node)\n                dfs(node.right, node)\n\n                if (par is None and node is not covered or\n                        node.left not in covered or node.right not in covered):\n                    self.ans += 1\n                    covered.update({node, par, node.left, node.right})\n\n        dfs(root)\n        return self.ans",
        "langSlug": "python"
      }
    ]
  },
  "topicTags": [
    "Dynamic Programming",
    "Tree",
    "Depth-first Search"
  ]
}