{
  "id": "127",
  "title": "Word Ladder",
  "slug": "word-ladder",
  "difficulty": "Medium",
  "likes": 1783,
  "dislikes": 887,
  "hints": [],
  "isPaidOnly": false,
  "similarQuestions": "[{\"title\": \"Word Ladder II\", \"titleSlug\": \"word-ladder-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Minimum Genetic Mutation\", \"titleSlug\": \"minimum-genetic-mutation\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
  "solution": {
    "id": "699",
    "canSeeDetail": true,
    "__typename": "ArticleNode",
    "9qj48p7V": [
      {
        "code": "import javafx.util.Pair;\n\nclass Solution {\n  public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n\n    // Since all words are of same length.\n    int L = beginWord.length();\n\n    // Dictionary to hold combination of words that can be formed,\n    // from any given word. By changing one letter at a time.\n    HashMap<String, ArrayList<String>> allComboDict = new HashMap<String, ArrayList<String>>();\n\n    wordList.forEach(\n        word -> {\n          for (int i = 0; i < L; i++) {\n            // Key is the generic word\n            // Value is a list of words which have the same intermediate generic word.\n            String newWord = word.substring(0, i) + '*' + word.substring(i + 1, L);\n            ArrayList<String> transformations =\n                allComboDict.getOrDefault(newWord, new ArrayList<String>());\n            transformations.add(word);\n            allComboDict.put(newWord, transformations);\n          }\n        });\n\n    // Queue for BFS\n    Queue<Pair<String, Integer>> Q = new LinkedList<Pair<String, Integer>>();\n    Q.add(new Pair(beginWord, 1));\n\n    // Visited to make sure we don't repeat processing same word.\n    HashMap<String, Boolean> visited = new HashMap<String, Boolean>();\n    visited.put(beginWord, true);\n\n    while (!Q.isEmpty()) {\n      Pair<String, Integer> node = Q.remove();\n      String word = node.getKey();\n      int level = node.getValue();\n      for (int i = 0; i < L; i++) {\n\n        // Intermediate words for current word\n        String newWord = word.substring(0, i) + '*' + word.substring(i + 1, L);\n\n        // Next states are all the words which share the same intermediate state.\n        for (String adjacentWord : allComboDict.getOrDefault(newWord, new ArrayList<String>())) {\n          // If at any point if we find what we are looking for\n          // i.e. the end word - we can return with the answer.\n          if (adjacentWord.equals(endWord)) {\n            return level + 1;\n          }\n          // Otherwise, add it to the BFS Queue. Also mark it visited\n          if (!visited.containsKey(adjacentWord)) {\n            visited.put(adjacentWord, true);\n            Q.add(new Pair(adjacentWord, level + 1));\n          }\n        }\n      }\n    }\n\n    return 0;\n  }\n}",
        "langSlug": "java"
      },
      {
        "code": "from collections import defaultdict\nclass Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n\n        if endWord not in wordList or not endWord or not beginWord or not wordList:\n            return 0\n\n        # Since all words are of same length.\n        L = len(beginWord)\n\n        # Dictionary to hold combination of words that can be formed,\n        # from any given word. By changing one letter at a time.\n        all_combo_dict = defaultdict(list)\n        for word in wordList:\n            for i in range(L):\n                # Key is the generic word\n                # Value is a list of words which have the same intermediate generic word.\n                all_combo_dict[word[:i] + \"*\" + word[i+1:]].append(word)\n\n\n        # Queue for BFS\n        queue = collections.deque([(beginWord, 1)])\n        # Visited to make sure we don't repeat processing same word.\n        visited = {beginWord: True}\n        while queue:\n            current_word, level = queue.popleft()      \n            for i in range(L):\n                # Intermediate words for current word\n                intermediate_word = current_word[:i] + \"*\" + current_word[i+1:]\n\n                # Next states are all the words which share the same intermediate state.\n                for word in all_combo_dict[intermediate_word]:\n                    # If at any point if we find what we are looking for\n                    # i.e. the end word - we can return with the answer.\n                    if word == endWord:\n                        return level + 1\n                    # Otherwise, add it to the BFS Queue. Also mark it visited\n                    if word not in visited:\n                        visited[word] = True\n                        queue.append((word, level + 1))\n                all_combo_dict[intermediate_word] = []\n        return 0",
        "langSlug": "python"
      }
    ],
    "QwU5MtQa": [
      {
        "code": "import javafx.util.Pair;\n\nclass Solution {\n\n  private int L;\n  private HashMap<String, ArrayList<String>> allComboDict;\n\n  Solution() {\n    this.L = 0;\n\n    // Dictionary to hold combination of words that can be formed,\n    // from any given word. By changing one letter at a time.\n    this.allComboDict = new HashMap<String, ArrayList<String>>();\n  }\n\n  private int visitWordNode(\n      Queue<Pair<String, Integer>> Q,\n      HashMap<String, Integer> visited,\n      HashMap<String, Integer> othersVisited) {\n    Pair<String, Integer> node = Q.remove();\n    String word = node.getKey();\n    int level = node.getValue();\n\n    for (int i = 0; i < this.L; i++) {\n\n      // Intermediate words for current word\n      String newWord = word.substring(0, i) + '*' + word.substring(i + 1, L);\n\n      // Next states are all the words which share the same intermediate state.\n      for (String adjacentWord : this.allComboDict.getOrDefault(newWord, new ArrayList<String>())) {\n        // If at any point if we find what we are looking for\n        // i.e. the end word - we can return with the answer.\n        if (othersVisited.containsKey(adjacentWord)) {\n          return level + othersVisited.get(adjacentWord);\n        }\n\n        if (!visited.containsKey(adjacentWord)) {\n\n          // Save the level as the value of the dictionary, to save number of hops.\n          visited.put(adjacentWord, level + 1);\n          Q.add(new Pair(adjacentWord, level + 1));\n        }\n      }\n    }\n    return -1;\n  }\n\n  public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n\n    if (!wordList.contains(endWord)) {\n      return 0;\n    }\n\n    // Since all words are of same length.\n    this.L = beginWord.length();\n\n    wordList.forEach(\n        word -> {\n          for (int i = 0; i < L; i++) {\n            // Key is the generic word\n            // Value is a list of words which have the same intermediate generic word.\n            String newWord = word.substring(0, i) + '*' + word.substring(i + 1, L);\n            ArrayList<String> transformations =\n                this.allComboDict.getOrDefault(newWord, new ArrayList<String>());\n            transformations.add(word);\n            this.allComboDict.put(newWord, transformations);\n          }\n        });\n\n    // Queues for birdirectional BFS\n    // BFS starting from beginWord\n    Queue<Pair<String, Integer>> Q_begin = new LinkedList<Pair<String, Integer>>();\n    // BFS starting from endWord\n    Queue<Pair<String, Integer>> Q_end = new LinkedList<Pair<String, Integer>>();\n    Q_begin.add(new Pair(beginWord, 1));\n    Q_end.add(new Pair(endWord, 1));\n\n    // Visited to make sure we don't repeat processing same word.\n    HashMap<String, Integer> visitedBegin = new HashMap<String, Integer>();\n    HashMap<String, Integer> visitedEnd = new HashMap<String, Integer>();\n    visitedBegin.put(beginWord, 1);\n    visitedEnd.put(endWord, 1);\n\n    while (!Q_begin.isEmpty() && !Q_end.isEmpty()) {\n\n      // One hop from begin word\n      int ans = visitWordNode(Q_begin, visitedBegin, visitedEnd);\n      if (ans > -1) {\n        return ans;\n      }\n\n      // One hop from end word\n      ans = visitWordNode(Q_end, visitedEnd, visitedBegin);\n      if (ans > -1) {\n        return ans;\n      }\n    }\n\n    return 0;\n  }\n}",
        "langSlug": "java"
      },
      {
        "code": "from collections import defaultdict\nclass Solution(object):\n    def __init__(self):\n        self.length = 0\n        # Dictionary to hold combination of words that can be formed,\n        # from any given word. By changing one letter at a time.\n        self.all_combo_dict = defaultdict(list)\n\n    def visitWordNode(self, queue, visited, others_visited):\n        current_word, level = queue.popleft()\n        for i in range(self.length):\n            # Intermediate words for current word\n            intermediate_word = current_word[:i] + \"*\" + current_word[i+1:]\n\n            # Next states are all the words which share the same intermediate state.\n            for word in self.all_combo_dict[intermediate_word]:\n                # If the intermediate state/word has already been visited from the\n                # other parallel traversal this means we have found the answer.\n                if word in others_visited:\n                    return level + others_visited[word]\n                if word not in visited:\n                    # Save the level as the value of the dictionary, to save number of hops.\n                    visited[word] = level + 1\n                    queue.append((word, level + 1))\n        return None\n\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n\n        if endWord not in wordList or not endWord or not beginWord or not wordList:\n            return 0\n\n        # Since all words are of same length.\n        self.length = len(beginWord)\n\n        for word in wordList:\n            for i in range(self.length):\n                # Key is the generic word\n                # Value is a list of words which have the same intermediate generic word.\n                self.all_combo_dict[word[:i] + \"*\" + word[i+1:]].append(word)\n\n\n        # Queues for birdirectional BFS\n        queue_begin = collections.deque([(beginWord, 1)]) # BFS starting from beginWord\n        queue_end = collections.deque([(endWord, 1)]) # BFS starting from endWord\n\n        # Visited to make sure we don't repeat processing same word\n        visited_begin = {beginWord: 1}\n        visited_end = {endWord: 1}\n        ans = None\n\n        # We do a birdirectional search starting one pointer from begin\n        # word and one pointer from end word. Hopping one by one.\n        while queue_begin and queue_end:\n\n            # One hop from begin word\n            ans = self.visitWordNode(queue_begin, visited_begin, visited_end)\n            if ans:\n                return ans\n            # One hop from end word\n            ans = self.visitWordNode(queue_end, visited_end, visited_begin)\n            if ans:\n                return ans\n\n        return 0",
        "langSlug": "python"
      }
    ]
  },
  "topicTags": [
    "Breadth-first Search"
  ]
}