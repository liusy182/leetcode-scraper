{
  "id": "943",
  "title": "Find the Shortest Superstring",
  "slug": "find-the-shortest-superstring",
  "difficulty": "Hard",
  "likes": 194,
  "dislikes": 55,
  "hints": [],
  "isPaidOnly": false,
  "similarQuestions": "[]",
  "solution": {
    "id": "619",
    "canSeeDetail": true,
    "__typename": "ArticleNode",
    "bMRiuMrv": [
      {
        "code": "class Solution {\n    public String shortestSuperstring(String[] A) {\n        int N = A.length;\n\n        // Populate overlaps\n        int[][] overlaps = new int[N][N];\n        for (int i = 0; i < N; ++i)\n            for (int j = 0; j < N; ++j) if (i != j) {\n                int m = Math.min(A[i].length(), A[j].length());\n                for (int k = m; k >= 0; --k)\n                    if (A[i].endsWith(A[j].substring(0, k))) {\n                        overlaps[i][j] = k;\n                        break;\n                    }\n            }\n\n        // dp[mask][i] = most overlap with mask, ending with ith element\n        int[][] dp = new int[1<<N][N];\n        int[][] parent = new int[1<<N][N];\n        for (int mask = 0; mask < (1<<N); ++mask) {\n            Arrays.fill(parent[mask], -1);\n\n            for (int bit = 0; bit < N; ++bit) if (((mask >> bit) & 1) > 0) {\n                // Let's try to find dp[mask][bit].  Previously, we had\n                // a collection of items represented by pmask.\n                int pmask = mask ^ (1 << bit);\n                if (pmask == 0) continue;\n                for (int i = 0; i < N; ++i) if (((pmask >> i) & 1) > 0) {\n                    // For each bit i in pmask, calculate the value\n                    // if we ended with word i, then added word 'bit'.\n                    int val = dp[pmask][i] + overlaps[i][bit];\n                    if (val > dp[mask][bit]) {\n                        dp[mask][bit] = val;\n                        parent[mask][bit] = i;\n                    }\n                }\n            }\n        }\n\n        // # Answer will have length sum(len(A[i]) for i) - max(dp[-1])\n        // Reconstruct answer, first as a sequence 'perm' representing\n        // the indices of each word from left to right.\n\n        int[] perm = new int[N];\n        boolean[] seen = new boolean[N];\n        int t = 0;\n        int mask = (1 << N) - 1;\n\n        // p: the last element of perm (last word written left to right)\n        int p = 0;\n        for (int j = 0; j < N; ++j)\n            if (dp[(1<<N) - 1][j] > dp[(1<<N) - 1][p])\n                p = j;\n\n        // Follow parents down backwards path that retains maximum overlap\n        while (p != -1) {\n            perm[t++] = p;\n            seen[p] = true;\n            int p2 = parent[mask][p];\n            mask ^= 1 << p;\n            p = p2;\n        }\n\n        // Reverse perm\n        for (int i = 0; i < t/2; ++i) {\n            int v = perm[i];\n            perm[i] = perm[t-1-i];\n            perm[t-1-i] = v;\n        }\n\n        // Fill in remaining words not yet added\n        for (int i = 0; i < N; ++i) if (!seen[i])\n            perm[t++] = i;\n\n        // Reconstruct final answer given perm\n        StringBuilder ans = new StringBuilder(A[perm[0]]);\n        for (int i = 1; i < N; ++i) {\n            int overlap = overlaps[perm[i-1]][perm[i]];\n            ans.append(A[perm[i]].substring(overlap));\n        }\n\n        return ans.toString();\n    }\n}\n",
        "langSlug": "java"
      },
      {
        "code": "class Solution(object):\n    def shortestSuperstring(self, A):\n        N = len(A)\n\n        # Populate overlaps\n        overlaps = [[0] * N for _ in xrange(N)]\n        for i, x in enumerate(A):\n            for j, y in enumerate(A):\n                if i != j:\n                    for ans in xrange(min(len(x), len(y)), -1, -1):\n                        if x.endswith(y[:ans]):\n                            overlaps[i][j] = ans\n                            break\n\n        # dp[mask][i] = most overlap with mask, ending with ith element\n        dp = [[0] * N for _ in xrange(1<<N)]\n        parent = [[None] * N for _ in xrange(1<<N)]\n        for mask in xrange(1, 1 << N):\n            for bit in xrange(N):\n                if (mask >> bit) & 1:\n                    # Let's try to find dp[mask][bit].  Previously, we had\n                    # a collection of items represented by pmask.\n                    pmask = mask ^ (1 << bit)\n                    if pmask == 0: continue\n                    for i in xrange(N):\n                        if (pmask >> i) & 1:\n                            # For each bit i in pmask, calculate the value\n                            # if we ended with word i, then added word 'bit'.\n                            value = dp[pmask][i] + overlaps[i][bit]\n                            if value > dp[mask][bit]:\n                                dp[mask][bit] = value\n                                parent[mask][bit] = i\n\n        # Answer will have length sum(len(A[i]) for i) - max(dp[-1])\n        # Reconstruct answer:\n\n        # Follow parents down backwards path that retains maximum overlap\n        perm = []\n        mask = (1<<N) - 1\n        i = max(xrange(N), key = dp[-1].__getitem__)\n        while i is not None:\n            perm.append(i)\n            mask, i = mask ^ (1<<i), parent[mask][i]\n\n        # Reverse path to get forwards direction; add all remaining words\n        perm = perm[::-1]\n        seen = [False] * N\n        for x in perm:\n            seen[x] = True\n        perm.extend([i for i in xrange(N) if not seen[i]])\n\n        # Reconstruct answer given perm = word indices in left to right order\n        ans = [A[perm[0]]]\n        for i in xrange(1, len(perm)):\n            overlap = overlaps[perm[i-1]][perm[i]]\n            ans.append(A[perm[i]][overlap:])\n\n        return \"\".join(ans)",
        "langSlug": "python"
      }
    ]
  },
  "topicTags": [
    "Dynamic Programming"
  ]
}