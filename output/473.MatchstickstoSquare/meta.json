{
  "id": "473",
  "title": "Matchsticks to Square",
  "slug": "matchsticks-to-square",
  "difficulty": "Medium",
  "likes": 367,
  "dislikes": 42,
  "hints": [
    "Treat the matchsticks as an array. Can we split the array into 4 equal halves?",
    "Every matchstick can belong to either of the 4 sides. We don't know which one. Maybe try out all options!",
    "For every matchstick, we have to try out each of the 4 options i.e. which side it can belong to. We can make use of recursion for this.",
    "We don't really need to keep track of which matchsticks belong to a particular side during recursion. We just need to keep track of the <b>length</b> of each of the 4 sides.",
    "When all matchsticks have been used we simply need to see the length of all 4 sides. If they're equal, we have a square on our hands!"
  ],
  "isPaidOnly": false,
  "similarQuestions": "[]",
  "solution": {
    "id": "540",
    "canSeeDetail": true,
    "__typename": "ArticleNode",
    "PcFBb5tW": [
      {
        "code": "import java.util.HashMap;\nimport java.util.Collections;\n\nclass Solution {\n    public List<Integer> nums;\n    public int[] sums;\n    public int possibleSquareSide;\n\n    public Solution() {\n        this.sums = new int[4];\n    }\n\n    // Depth First Search function.\n    public boolean dfs(int index) {\n\n        // If we have exhausted all our matchsticks, check if all sides of the square are of equal length\n        if (index == this.nums.size()) {\n            return sums[0] == sums[1] && sums[1] == sums[2] && sums[2] == sums[3];\n        }\n\n        // Get current matchstick.\n        int element = this.nums.get(index);\n\n        // Try adding it to each of the 4 sides (if possible)\n        for(int i = 0; i < 4; i++) {\n            if (this.sums[i] + element <= this.possibleSquareSide) {\n                this.sums[i] += element;\n                if (this.dfs(index + 1)) {\n                    return true;\n                }\n                this.sums[i] -= element;\n            }\n        }\n\n        return false;\n    }\n\n    public boolean makesquare(int[] nums) {\n        // Empty matchsticks.\n        if (nums == null || nums.length == 0) {\n            return false;\n        }\n\n        // Find the perimeter of the square (if at all possible)\n        int L = nums.length;\n        int perimeter = 0;\n        for(int i = 0; i < L; i++) {\n            perimeter += nums[i];\n        }\n\n        this.possibleSquareSide =  perimeter / 4;\n        if (this.possibleSquareSide * 4 != perimeter) {\n            return false;\n        }\n\n        // Convert the array of primitive int to ArrayList (for sorting).\n        this.nums = Arrays.stream(nums).boxed().collect(Collectors.toList());\n        Collections.sort(this.nums, Collections.reverseOrder());\n        return this.dfs(0);\n    }\n}",
        "langSlug": "java"
      },
      {
        "code": "def makesquare(self, nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: bool\n    \"\"\"\n\n    # If there are no matchsticks, then we can't form any square\n    if not nums:\n        return False\n\n    # Number of matchsticks we have\n    L = len(nums)\n\n    # Perimeter of our square (if one can be formed)\n    perimeter = sum(nums)\n\n    # Possible side of our square.\n    possible_side =  perimeter // 4\n\n    # If the perimeter can be equally split into 4 parts (and hence 4 sides, then we move on).\n    if possible_side * 4 != perimeter:\n        return False\n\n    # Reverse sort the matchsticks because we want to consider the biggest one first.\n    nums.sort(reverse=True)\n\n    # This array represents the 4 sides and their current lengths\n    sums = [0 for _ in range(4)]\n\n    # Our recursive dfs function.\n    def dfs(index):\n\n        # If we reach the end of matchsticks array, we check if the square was formed or not\n        if index == L:\n            # If 3 equal sides were formed, 4th will be the same as these three and answer should be True in that case.\n            return sums[0] == sums[1] == sums[2] == possible_side\n\n        # The current matchstick can belong to any of the 4 sides (provided their remaining lenghts are >= the size of the current matchstick)\n        for i in range(4):\n            # If this matchstick can fir in the space left for the current side\n            if sums[i] + nums[index] <= possible_side:\n                # Recurse\n                sums[i] += nums[index]\n                if dfs(index + 1):\n                    return True\n                # Revert the effects of recursion because we no longer need them for other recursions.\n                sums[i] -= nums[index]\n        return False        \n    return dfs(0)",
        "langSlug": "python"
      }
    ],
    "yNytHY5x": [
      {
        "code": "import java.util.HashMap;\nimport javafx.util.Pair;\n\nclass Solution {\n\n    // The memoization cache to be used during recursion.\n    public HashMap<Pair<Integer, Integer>, Boolean> memo;\n\n    // Array containing our matchsticks.\n    public int[] nums;\n\n    // Possible side of our square depending on the total sum of all the matchsticks.\u00a0\n    public int possibleSquareSide;\n\n    // Default constructor to initialise our memo cache.\n    public Solution() {\n        this.memo = new HashMap<Pair<Integer, Integer>, Boolean>();\n    }\n\n    // Main DP function.\n    public boolean recurse(Integer mask, Integer sidesDone) {\n        int total = 0;\n        int L = this.nums.length;\n\n        // The memo key for this recursion\n        Pair<Integer, Integer> memoKey = new Pair(mask, sidesDone);\n\n        // Find out the sum of matchsticks used till now.\n        for(int i = L - 1; i >= 0; i--) {\n            if ((mask&(1 << i)) == 0) {\n                total += this.nums[L - 1 - i];\n            }\n        }\n\n        // If the sum if divisible by our square's side, then we increment our number of complete sides formed variable.\n        if (total > 0 && total % this.possibleSquareSide == 0) {\n            sidesDone++;\n        }\n\n        // Base case.\n        if (sidesDone == 3) {\n            return true;\n        }\n\n\n        // Return precomputed results\n        if (this.memo.containsKey(memoKey)) {\n            return this.memo.get(memoKey);\n        }\n\n        boolean ans = false;\n        int c = total / this.possibleSquareSide;\n\n        // Remaining vlength in the current partially formed side.\n        int rem = this.possibleSquareSide * (c + 1) - total;\n\n        // Try out all remaining options (that are valid)\n        for(int i = L - 1; i >= 0; i--) {\n            if (this.nums[L - 1 - i] <= rem && (mask&(1 << i)) > 0) {\n                if (this.recurse(mask ^ (1 << i), sidesDone)) {\n                    ans = true;\n                    break;\n                }\n            }\n        }\n\n        // Cache the computed results.\n        this.memo.put(memoKey, ans);\n        return ans;\n    }\n\n    public boolean makesquare(int[] nums) {\n\n        // Empty matchsticks.\n        if (nums == null || nums.length == 0) {\n            return false;\n        }\n\n        // Find the perimeter of the square (if at all possible)\n        int L = nums.length;\n        int perimeter = 0;\n        for(int i = 0; i < L; i++) {\n            perimeter += nums[i];\n        }\n\n        int possibleSquareSide =  perimeter / 4;\n        if (possibleSquareSide * 4 != perimeter) {\n            return false;\n        }\n\n        this.nums = nums;\n        this.possibleSquareSide = possibleSquareSide;\n        return this.recurse((1 << L) - 1, 0);\n    }\n}",
        "langSlug": "java"
      },
      {
        "code": "def makesquare(self, nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: bool\n    \"\"\"\n\n    # If there are no matchsticks, then we can't form any square.\n    if not nums:\n        return False\n\n    # Number of matchsticks\n    L = len(nums)\n\n    # Possible perimeter of our square\n    perimeter = sum(nums)\n\n    # Possible side of our square from the given matchsticks\n    possible_side =  perimeter // 4\n\n    # If the perimeter isn't equally divisible among 4 sides, return False.\n    if possible_side * 4 != perimeter:\n        return False\n\n    # Memoization cache for the dynamic programming solution.\n    memo = {}\n\n    # mask and the sides_done define the state of our recursion.\n    def recurse(mask, sides_done):\n\n        # This will calculate the total sum of matchsticks used till now using the bits of the mask.\n        total = 0\n        for i in range(L - 1, -1, -1):\n            if not (mask & (1 << i)):\n                total += nums[L - 1 - i]\n\n        # If some of the matchsticks have been used and the sum is divisible by our square's side, then we increment the number of sides completed.\n        if total > 0 and total % possible_side == 0:\n            sides_done += 1\n\n        # If we were successfully able to form 3 sides, return True\n        if sides_done == 3:\n            return True\n\n        # If this recursion state has already been calculated, just return the stored value.\n        if (mask, sides_done) in memo:\n            return memo[(mask, sides_done)]\n\n        # Common variable to store answer from all possible further recursions from this step.\n        ans = False\n\n        # rem stores available space in the current side (incomplete).\n        c = int(total / possible_side)\n        rem = possible_side * (c + 1) - total\n\n        # Iterate over all the matchsticks\n        for i in range(L - 1, -1, -1):\n\n            # If the current one can fit in the remaining space of the side and it hasn't already been taken, then try it out\n            if nums[L - 1 - i] <= rem and mask&(1 << i):\n\n                # If the recursion after considering this matchstick gives a True result, just break. No need to look any further.\n                # mask ^ (1 << i) makes the i^th from the right, 0 making it unavailable in future recursions.\n                if recurse(mask ^ (1 << i), sides_done):\n                    ans = True\n                    break\n        # cache the result for the current recursion state.            \n        memo[(mask, sides_done)] = ans\n        return ans\n\n    # recurse with the initial mask with all matchsticks available.\n    return recurse((1 << L) - 1, 0)",
        "langSlug": "python"
      }
    ]
  },
  "topicTags": [
    "Depth-first Search"
  ]
}