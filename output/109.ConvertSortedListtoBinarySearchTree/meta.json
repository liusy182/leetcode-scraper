{
  "id": "109",
  "title": "Convert Sorted List to Binary Search Tree",
  "slug": "convert-sorted-list-to-binary-search-tree",
  "difficulty": "Medium",
  "likes": 1205,
  "dislikes": 73,
  "hints": [],
  "isPaidOnly": false,
  "similarQuestions": "[{\"title\": \"Convert Sorted Array to Binary Search Tree\", \"titleSlug\": \"convert-sorted-array-to-binary-search-tree\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
  "solution": {
    "id": "614",
    "canSeeDetail": true,
    "__typename": "ArticleNode",
    "xhGFXBfU": [
      {
        "code": "/**\n * Definition for singly-linked list. public class ListNode { int val; ListNode next; ListNode(int\n * x) { val = x; } }\n */\n/**\n * Definition for a binary tree node. public class TreeNode { int val; TreeNode left; TreeNode\n * right; TreeNode(int x) { val = x; } }\n */\nclass Solution {\n\n  private ListNode findMiddleElement(ListNode head) {\n\n    // The pointer used to disconnect the left half from the mid node.\n    ListNode prevPtr = null;\n    ListNode slowPtr = head;\n    ListNode fastPtr = head;\n\n    // Iterate until fastPr doesn't reach the end of the linked list.\n    while (fastPtr != null && fastPtr.next != null) {\n      prevPtr = slowPtr;\n      slowPtr = slowPtr.next;\n      fastPtr = fastPtr.next.next;\n    }\n\n    // Handling the case when slowPtr was equal to head.\n    if (prevPtr != null) {\n      prevPtr.next = null;\n    }\n\n    return slowPtr;\n  }\n\n  public TreeNode sortedListToBST(ListNode head) {\n\n    // If the head doesn't exist, then the linked list is empty\n    if (head == null) {\n      return null;\n    }\n\n    // Find the middle element for the list.\n    ListNode mid = this.findMiddleElement(head);\n\n    // The mid becomes the root of the BST.\n    TreeNode node = new TreeNode(mid.val);\n\n    // Base case when there is just one element in the linked list\n    if (head == mid) {\n      return node;\n    }\n\n    // Recursively form balanced BSTs using the left and right halves of the original list.\n    node.left = this.sortedListToBST(head);\n    node.right = this.sortedListToBST(mid.next);\n    return node;\n  }\n}",
        "langSlug": "java"
      },
      {
        "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n\n    def findMiddle(self, head):\n\n        # The pointer used to disconnect the left half from the mid node.\n        prevPtr = None\n        slowPtr = head\n        fastPtr = head\n\n        # Iterate until fastPr doesn't reach the end of the linked list.\n        while fastPtr and fastPtr.next:\n            prevPtr = slowPtr\n            slowPtr = slowPtr.next\n            fastPtr = fastPtr.next.next\n\n        # Handling the case when slowPtr was equal to head.\n        if prevPtr:\n            prevPtr.next = None\n\n        return slowPtr\n\n\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: TreeNode\n        \"\"\"\n\n        # If the head doesn't exist, then the linked list is empty\n        if not head:\n            return None\n\n        # Find the middle element for the list.\n        mid = self.findMiddle(head)\n\n        # The mid becomes the root of the BST.\n        node = TreeNode(mid.val)\n\n        # Base case when there is just one element in the linked list\n        if head == mid:\n            return node\n\n        # Recursively form balanced BSTs using the left and right halves of the original list.\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(mid.next)\n        return node",
        "langSlug": "python"
      }
    ],
    "c8hTLmwD": [
      {
        "code": "/**\n * Definition for singly-linked list. public class ListNode { int val; ListNode next; ListNode(int\n * x) { val = x; } }\n */\n/**\n * Definition for a binary tree node. public class TreeNode { int val; TreeNode left; TreeNode\n * right; TreeNode(int x) { val = x; } }\n */\nclass Solution {\n\n  private List<Integer> values;\n\n  public Solution() {\n    this.values = new ArrayList<Integer>();\n  }\n\n  private void mapListToValues(ListNode head) {\n    while (head != null) {\n      this.values.add(head.val);\n      head = head.next;\n    }\n  }\n\n  private TreeNode convertListToBST(int left, int right) {\n    // Invalid case\n    if (left > right) {\n      return null;\n    }\n\n    // Middle element forms the root.\n    int mid = (left + right) / 2;\n    TreeNode node = new TreeNode(this.values.get(mid));\n\n    // Base case for when there is only one element left in the array\n    if (left == right) {\n      return node;\n    }\n\n    // Recursively form BST on the two halves\n    node.left = convertListToBST(left, mid - 1);\n    node.right = convertListToBST(mid + 1, right);\n    return node;\n  }\n\n  public TreeNode sortedListToBST(ListNode head) {\n\n    // Form an array out of the given linked list and then\n    // use the array to form the BST.\n    this.mapListToValues(head);\n\n    // Convert the array to\n    return convertListToBST(0, this.values.size() - 1);\n  }\n}",
        "langSlug": "java"
      },
      {
        "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n\n    # Convert the given linked list to an array\n    def mapListToValues(self, head):\n        vals = []\n        while head:\n            vals.append(head.val)\n            head = head.next\n        return vals    \n\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: TreeNode\n        \"\"\"\n\n        # Form an array out of the given linked list and then\n        # use the array to form the BST.\n        values = self.mapListToValues(head)\n\n        # l and r represent the start and end of the given array\n        def convertListToBST(l, r):\n\n            # Invalid case\n            if l > r:\n                return None\n\n            # Middle element forms the root.\n            mid = (l + r) // 2\n            node = TreeNode(values[mid])\n\n            # Base case for when there is only one element left in the array\n            if l == r:\n                return node\n\n            # Recursively form BST on the two halves\n            node.left = convertListToBST(l, mid - 1)\n            node.right = convertListToBST(mid + 1, r)\n            return node\n        return convertListToBST(0, len(values) - 1)",
        "langSlug": "python"
      }
    ],
    "V2CBnnrM": [
      {
        "code": "/**\n * Definition for singly-linked list. public class ListNode { int val; ListNode next; ListNode(int\n * x) { val = x; } }\n */\n/**\n * Definition for a binary tree node. public class TreeNode { int val; TreeNode left; TreeNode\n * right; TreeNode(int x) { val = x; } }\n */\nclass Solution {\n\n  private ListNode head;\n\n  private int findSize(ListNode head) {\n    ListNode ptr = head;\n    int c = 0;\n    while (ptr != null) {\n      ptr = ptr.next;  \n      c += 1;\n    }\n    return c;\n  }\n\n  private TreeNode convertListToBST(int l, int r) {\n    // Invalid case\n    if (l > r) {\n      return null;\n    }\n\n    int mid = (l + r) / 2;\n\n    // First step of simulated inorder traversal. Recursively form\n    // the left half\n    TreeNode left = this.convertListToBST(l, mid - 1);\n\n    // Once left half is traversed, process the current node\n    TreeNode node = new TreeNode(this.head.val);\n    node.left = left;\n\n    // Maintain the invariance mentioned in the algorithm\n    this.head = this.head.next;\n\n    // Recurse on the right hand side and form BST out of them\n    node.right = this.convertListToBST(mid + 1, r);\n    return node;\n  }\n\n  public TreeNode sortedListToBST(ListNode head) {\n    // Get the size of the linked list first\n    int size = this.findSize(head);\n\n    this.head = head;\n\n    // Form the BST now that we know the size\n    return convertListToBST(0, size - 1);\n  }\n}",
        "langSlug": "java"
      },
      {
        "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n\n    def findSize(self, head):\n        ptr = head\n        c = 0\n        while ptr:\n            ptr = ptr.next\n            c += 1\n        return c\n\n\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: TreeNode\n        \"\"\"\n\n        # Get the size of the linked list first\n        size = self.findSize(head)\n\n        # Recursively form a BST out of linked list from l --> r\n        def convert(l, r):\n            nonlocal head\n\n            # Invalid case\n            if l > r:\n                return None\n\n            mid = (l + r) // 2\n\n            # First step of simulated inorder traversal. Recursively form\n            # the left half\n            left = convert(l, mid - 1)\n\n            # Once left half is traversed, process the current node\n            node = TreeNode(head.val)   \n            node.left = left\n\n            # Maintain the invariance mentioned in the algorithm\n            head = head.next\n\n            # Recurse on the right hand side and form BST out of them\n            node.right = convert(mid + 1, r)\n            return node\n        return convert(0, size - 1)",
        "langSlug": "python"
      }
    ]
  },
  "topicTags": [
    "Linked List",
    "Depth-first Search"
  ]
}